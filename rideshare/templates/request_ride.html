{% extends 'base.html' %}
{% load static %}

{% block title %}Request a Ride - Rideon{% endblock %}

{% block extra_head %}
<!-- Google Maps API with Web Components - Multiple Loading Approaches -->
<!-- Note: Using places library which includes both legacy Autocomplete and new PlaceAutocompleteElement -->
<script async defer 
    src="https://maps.googleapis.com/maps/api/js?key={{ google_maps_api_key }}&callback=initGoogleMaps&libraries=places,geometry&v=beta"
    onerror="handleGoogleMapsError()">
</script>
<!-- Alternative Google Maps API script without beta -->
<script id="google-maps-fallback" type="text/javascript" style="display: none;">
    // Fallback script will be created dynamically if needed
</script>
<!-- Leaflet CSS (fallback) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<!-- Leaflet Routing Machine CSS (fallback) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
<!-- Google Maps Extended Component Library with error handling -->
<script type="module" 
    src="https://ajax.googleapis.com/ajax/libs/@googlemaps/extended-component-library/0.6.11/index.min.js"
    onerror="handleExtendedComponentsError()">
</script>

<style>
    /* Google Maps Web Component Styling */
    gmp-map {
        width: 100%;
        height: 100%;
        min-height: 300px;
        display: block !important;
        position: relative;
        z-index: 1;
    }
    
    #map {
        width: 100%;
        height: 100%;
        min-height: 300px;
        display: block !important;
        position: relative;
        z-index: 1;
    }
    
    .map-container {
        position: relative;
        height: 300px;
        background-color: #f8f9fa;
    }
    .suggestions-dropdown {
        border-color: #dee2e6 !important;
    }
    .suggestion-item {
        padding: 12px 16px;
        cursor: pointer;
        border-bottom: 1px solid #f8f9fa;
        transition: background-color 0.2s ease;
    }
    .suggestion-item:last-child {
        border-bottom: none;
    }
    .suggestion-item:hover {
        background-color: #f8f9fa;
    }
    .suggestion-item.active {
        background-color: #e3f2fd;
    }
    .suggestion-main {
        font-weight: 500;
        color: #212529;
    }
    .suggestion-sub {
        font-size: 0.875rem;
        color: #6c757d;
        margin-top: 2px;
    }
    
    /* Custom styles for user location marker */
    .user-location-marker {
        background: none !important;
        border: none !important;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .user-location-marker i {
        text-shadow: 0 0 3px rgba(255,255,255,0.8);
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    }
    
    /* Google Places Autocomplete styling */
    .pac-container {
        background-color: #fff;
        z-index: 1051;
        position: fixed;
        display: inline-block;
        float: left;
        border-radius: 6px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        border: 1px solid #ccc;
    }
    
    .pac-item {
        cursor: pointer;
        padding: 12px 16px;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        line-height: 30px;
        text-align: left;
        border-bottom: 1px solid #e9ecef;
        font-size: 14px;
    }
    
    .pac-item:hover {
        background-color: #f8f9fa;
    }
    
    .pac-item-selected {
        background-color: #e3f2fd;
    }
    
    .pac-matched {
        font-weight: 600;
        color: #007bff;
    }
    
    .pac-item-query {
        font-size: 13px;
        padding-right: 3px;
        color: #666;
    }
    
    .pac-icon {
        width: 15px;
        height: 20px;
        margin-right: 7px;
        margin-top: 6px;
        display: inline-block;
        vertical-align: top;
        background-image: url(//maps.gstatic.com/mapfiles/place_api/icons/geocode-71.png);
        background-size: 15px 20px;
    }

    /* Popular Destinations Dropdown Styling */
    #destination-info {
        font-size: 0.875rem;
        line-height: 1.4;
    }
    
    .destination-error {
        color: #dc3545;
        font-size: 12px;
        margin-top: 4px;
    }
</style>
{% endblock %}

{% block content %}
<!-- Alert Container for JavaScript messages -->
<div id="alert-container" class="position-fixed" style="top: 20px; right: 20px; z-index: 9999; max-width: 400px;">
</div>

<gmpx-api-loader key="{{ google_maps_api_key }}" solution-channel="GMP_GE_rideshare_v1">
</gmpx-api-loader>
<div class="container py-4">
    <div class="row justify-content-center">
        <div class="col-lg-8">
            <div class="card shadow">
                <div class="card-header bg-primary text-white">
                    <h4 class="mb-0">
                        <i class="fas fa-plus me-2"></i>Request a Ride
                    </h4>
                </div>
                <div class="card-body p-4">
                    <form id="ride-request-form" method="post" action="/api/" onsubmit="return false;">
                        {% csrf_token %}
                        <!-- Ride Type Selection -->
                        <div class="mb-4">
                            <label class="form-label fw-bold">
                                <i class="fas fa-clock text-primary me-2"></i>Ride Type *
                            </label>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="ride_type" id="immediate" value="immediate" checked>
                                        <label class="form-check-label" for="immediate">
                                            <i class="fas fa-bolt text-warning me-2"></i>Ride Now
                                            <small class="d-block text-muted">Get picked up immediately</small>
                                        </label>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="ride_type" id="scheduled" value="scheduled">
                                        <label class="form-check-label" for="scheduled">
                                            <i class="fas fa-calendar-alt text-info me-2"></i>Schedule Ride
                                            <small class="d-block text-muted">Schedule for later</small>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Scheduled Time (hidden by default) -->
                        <div class="mb-4 d-none" id="scheduled-time-section">
                            <label for="scheduled_pickup_time" class="form-label fw-bold">
                                <i class="fas fa-clock text-info me-2"></i>Pickup Time *
                            </label>
                            <input type="datetime-local" class="form-control" id="scheduled_pickup_time" name="scheduled_pickup_time">
                            <small class="form-text text-muted">Select when you want to be picked up</small>
                        </div>

                        <!-- Pickup Location -->
                        <div class="mb-4">
                            <label for="pickup_location" class="form-label fw-bold">
                                <i class="fas fa-map-marker-alt text-success me-2"></i>Pickup Location *
                            </label>
                            <div class="input-group position-relative">
                                <input type="text" class="form-control" id="pickup_location" name="pickup_location" 
                                       placeholder="Enter pickup address (e.g., 123 Ikeja Road, Lagos)" required
                                       autocomplete="off">
                                <gmpx-place-picker placeholder="Enter an address"></gmpx-place-picker>
                                <button class="btn btn-outline-secondary" type="button" onclick="getCurrentLocation('pickup')" title="Use current location">
                                    <i class="fas fa-crosshairs"></i>
                                </button>
                                <button class="btn btn-outline-primary" type="button" onclick="searchLocation('pickup')" title="Search location">
                                    <i class="fas fa-search"></i>
                                </button>
                                <!-- Suggestions dropdown -->
                                <div id="pickup-suggestions" class="suggestions-dropdown position-absolute w-100 bg-white border rounded shadow-sm d-none" style="top: 100%; z-index: 1000; max-height: 200px; overflow-y: auto;">
                                    <!-- Suggestions will be populated here -->
                                </div>
                            </div>
                            <input type="hidden" id="pickup_latitude" name="pickup_latitude">
                            <input type="hidden" id="pickup_longitude" name="pickup_longitude">
                            <small class="form-text text-muted">Enter a full address for better accuracy</small>
                        </div>

                        <!-- Dropoff Location -->
                        <div class="mb-4">
                            <label for="dropoff_location" class="form-label fw-bold">
                                <i class="fas fa-flag text-danger me-2"></i>Dropoff Location *
                            </label>
                            <div class="input-group position-relative">
                                <input type="text" class="form-control" id="dropoff_location" name="dropoff_location" 
                                       placeholder="Enter destination address (e.g., 456 Victoria Island, Lagos)" required
                                       autocomplete="off">
                                <button class="btn btn-outline-primary" type="button" onclick="searchLocation('dropoff')" title="Search location">
                                    <i class="fas fa-search"></i>
                                </button>
                                <!-- Suggestions dropdown -->
                                <div id="dropoff-suggestions" class="suggestions-dropdown position-absolute w-100 bg-white border rounded shadow-sm d-none" style="top: 100%; z-index: 1000; max-height: 200px; overflow-y: auto;">
                                    <!-- Suggestions will be populated here -->
                                </div>
                            </div>
                            <input type="hidden" id="dropoff_latitude" name="dropoff_latitude">
                            <input type="hidden" id="dropoff_longitude" name="dropoff_longitude">
                            <small class="form-text text-muted">Enter a full address for better accuracy</small>
                        </div>

                        <!-- Interactive Map -->
                        <div class="mb-4">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label fw-bold mb-0">
                                    <i class="fas fa-map me-2"></i>Route Preview
                                </label>
                            </div>
                            <div class="map-container border rounded" style="height: 300px; position: relative;">
                                <gmp-map 
                                    id="map" 
                                    center="6.5244,3.3792" 
                                    zoom="12" 
                                    map-id="RIDEON_MAP_ID"
                                    style="width: 100%; height: 100%;">
                                    <!-- User location marker will be added dynamically -->
                                    <gmp-advanced-marker id="user-marker" class="d-none"></gmp-advanced-marker>
                                    <!-- Pickup location marker will be added dynamically -->
                                    <gmp-advanced-marker id="pickup-marker" class="d-none"></gmp-advanced-marker>
                                    <!-- Dropoff location marker will be added dynamically -->
                                    <gmp-advanced-marker id="dropoff-marker" class="d-none"></gmp-advanced-marker>
                                </gmp-map>
                                <!-- Fallback div for Leaflet -->
                                <div id="leaflet-map" class="d-none" style="width: 100%; height: 100%;"></div>
                            </div>
                            <small class="form-text text-muted">
                                <i class="fas fa-info-circle me-1"></i>
                                Map will show your route and estimated distance once locations are set
                            </small>
                        </div>

                        <!-- Popular Destinations Dropdown -->
                        <div class="mb-4">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label fw-bold mb-0">
                                    <i class="fas fa-map-marker-alt text-info me-2"></i>Popular Destinations
                                </label>
                                <button type="button" class="btn btn-sm btn-outline-info" onclick="refreshCommuteTimes()">
                                    <i class="fas fa-sync me-1"></i>Refresh Times
                                </button>
                            </div>
                            <div class="row">
                                <div class="col-md-8">
                                    <select class="form-select" id="popular-destinations" onchange="selectPopularDestination()">
                                        <option value="">Select a popular destination...</option>
                                        <!-- Options will be populated dynamically -->
                                    </select>
                                </div>
                                <div class="col-md-4">
                                    <div class="d-flex align-items-center">
                                        <span class="text-muted me-2" id="destination-info">
                                            <i class="fas fa-info-circle me-1"></i>Choose destination above
                                        </span>
                                    </div>
                                </div>
                            </div>
                            <small class="form-text text-muted">
                                <i class="fas fa-info-circle me-1"></i>
                                Select a popular destination to automatically set it as your dropoff location
                            </small>
                        </div>

                        <!-- Ride Details -->
                        <div class="row mb-4">
                            <div class="col-md-4">
                                <div class="card bg-light">
                                    <div class="card-body text-center">
                                        <i class="fas fa-route text-primary mb-2"></i>
                                        <h6>Distance</h6>
                                        <p class="mb-0" id="estimated-distance">--</p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="card bg-light">
                                    <div class="card-body text-center">
                                        <i class="fas fa-clock text-warning mb-2"></i>
                                        <h6>Duration</h6>
                                        <p class="mb-0" id="estimated-duration">--</p>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="card bg-light">
                                    <div class="card-body text-center">
                                        <i class="fas fa-dollar-sign text-success mb-2"></i>
                                        <h6>Estimated Fare</h6>
                                        <p class="mb-0" id="estimated-fare">--</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Payment Method -->
                        <div class="mb-4">
                            <label class="form-label fw-bold">
                                <i class="fas fa-credit-card text-success me-2"></i>Payment Method *
                            </label>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="payment_method" id="cash" value="cash" checked>
                                        <label class="form-check-label" for="cash">
                                            <i class="fas fa-money-bill-wave text-success me-2"></i>Cash
                                            <small class="d-block text-muted">Pay with cash upon completion</small>
                                        </label>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="payment_method" id="card" value="card" disabled>
                                        <label class="form-check-label text-muted" for="card">
                                            <i class="fas fa-credit-card text-muted me-2"></i>Credit/Debit Card
                                            <small class="d-block text-muted">Coming soon</small>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Additional Notes -->
                        <div class="mb-4">
                            <label for="notes" class="form-label fw-bold">
                                <i class="fas fa-comment me-2"></i>Additional Notes (Optional)
                            </label>
                            <textarea class="form-control" id="notes" name="notes" rows="3" 
                                      placeholder="Any special instructions for the driver, incase offline input your contact"></textarea>
                        </div>

                        <!-- Submit Button -->
                        <div class="d-grid gap-2">
                            <button type="button" class="btn btn-primary btn-lg" id="submit-btn" onclick="handleRideRequestClick(event)">
                                <i class="fas fa-paper-plane me-2"></i>
                                <span id="submit-text">Request Ride</span>
                                <div class="spinner-border spinner-border-sm d-none" id="submit-spinner"></div>
                            </button>
                            <a href="/dashboard/" class="btn btn-outline-secondary">
                                <i class="fas fa-arrow-left me-2"></i>Back to Dashboard
                            </a>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Success Modal -->
<div class="modal fade" id="success-modal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header bg-success text-white">
                <h5 class="modal-title">
                    <i class="fas fa-check-circle me-2"></i>Ride Requested Successfully!
                </h5>
            </div>
            <div class="modal-body text-center py-4">
                <i class="fas fa-car text-success display-4 mb-3"></i>
                <h5>Your ride has been requested</h5>
                <p class="text-muted">We're looking for nearby drivers. You'll be notified when a driver accepts your ride.</p>
                <div class="alert alert-info mt-3">
                    <i class="fas fa-info-circle me-2"></i>
                    <strong>Ride ID:</strong> <span id="ride-id">--</span>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-success" onclick="goToDashboard()">
                    <i class="fas fa-tachometer-alt me-2"></i>Go to Dashboard
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- Leaflet JS (fallback) -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Leaflet Routing Machine JS (fallback) -->
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

<script>
// Global fare configuration (loaded from backend) - Declared first to avoid initialization issues
var FARE_CONFIG = {
    base_fare: 100,
    per_km_rate: 50,
    currency: 'NGN',
    currency_symbol: 'â‚¦'
};

// Google Maps API Key from backend
var GOOGLE_MAPS_API_KEY = '{{ google_maps_api_key }}';

// Global variables for map system
let map;
let pickupMarker;
let dropoffMarker;
let userLocationMarker;
let routingControl;
let directionsService;
let directionsRenderer;
let placesService;
let isWebComponent = false;

// Commute destinations global variables
let commuteDestinationMarkers = [];
let directionsServiceCommute = null;

// Commute destinations data
const commuteDestinations = [
    { name: 'Victoria Island', lat: 6.4281, lng: 3.4219, icon: 'building' },
    { name: 'Lekki Phase 1', lat: 6.4376, lng: 3.4697, icon: 'home' },
    { name: 'Surulere', lat: 6.5027, lng: 3.3589, icon: 'shopping-cart' },
    { name: 'Maryland Mall', lat: 6.5568, lng: 3.3739, icon: 'shopping-bag' },
    { name: 'Murtala Muhammed Airport', lat: 6.5774, lng: 3.3212, icon: 'plane' },
    { name: 'University of Lagos', lat: 6.5158, lng: 3.3895, icon: 'graduation-cap' },
    { name: 'National Theatre', lat: 6.4647, lng: 3.3762, icon: 'theater-masks' },
    { name: 'Lagos Island', lat: 6.4550, lng: 3.3841, icon: 'landmark' }
];

// Map system flags
window.useGoogleMaps = false;
window.googleMapsLoaded = false;
window.extendedComponentsLoaded = false;

// Initialize global variables
window.leafletControl = null;
window.leafletMarkers = [];
window.leafletRouteLine = null;

// Error handling for script loading
window.handleGoogleMapsError = function() {
    console.error('Google Maps API failed to load, falling back to Leaflet');
    window.googleMapsLoaded = false;
    window.useGoogleMaps = false;
    tryFallbackGoogleMaps();
};

window.handleExtendedComponentsError = function() {
    console.error('Extended Components Library failed to load');
    window.extendedComponentsLoaded = false;
    // Try traditional Google Maps if available
    if (typeof google !== 'undefined' && google.maps) {
        console.log('Using traditional Google Maps instead of Web Components');
        isWebComponent = false;
        window.useGoogleMaps = true;
        initTraditionalGoogleMaps();
    } else {
        fallbackToLeaflet();
    }
};

// Try fallback Google Maps without beta version
function tryFallbackGoogleMaps() {
    console.log('Trying fallback Google Maps without beta version...');
    
    // Remove the failed script
    const failedScript = document.querySelector('script[src*="maps.googleapis.com"]');
    if (failedScript && failedScript.parentNode) {
        failedScript.parentNode.removeChild(failedScript);
    }
    
    // Create new script tag with stable version
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&callback=initTraditionalGoogleMaps&libraries=places,geometry`;
    script.async = true;
    script.defer = true;
    script.onerror = () => {
        console.error('Fallback Google Maps also failed, using Leaflet');
        fallbackToLeaflet();
    };
    
    document.head.appendChild(script);
}

// Initialize traditional Google Maps (non-beta)
window.initTraditionalGoogleMaps = function() {
    console.log('Traditional Google Maps API loaded');
    
    // Clear any existing timeouts or intervals
    if (window.googleMapsCheckInterval) {
        clearInterval(window.googleMapsCheckInterval);
        window.googleMapsCheckInterval = null;
    }
    
    // Force traditional mode and initialize
    isWebComponent = false;
    setTimeout(() => {
        console.log('Initializing traditional Google Maps from callback...');
        initializeGoogleMapsSystem();
    }, 100);
};

// Initialize traditional Google Maps
function initTraditionalMap() {
    try {
        const mapElement = document.getElementById('map');
        
        if (!mapElement) {
            console.error('Map element not found');
            fallbackToLeaflet();
            return;
        }
        
        console.log('Initializing traditional Google Maps...');
        
        // Hide Web Component and show traditional div
        mapElement.style.display = 'block';
        const leafletMap = document.getElementById('leaflet-map');
        if (leafletMap) {
            leafletMap.classList.add('d-none');
        }
        
        // Initialize traditional Google Maps
        map = new google.maps.Map(mapElement, {
            center: { lat: 6.5244, lng: 3.3792 },
            zoom: 12,
            mapTypeId: google.maps.MapTypeId.ROADMAP,
            zoomControl: true,
            mapTypeControl: false,
            scaleControl: true,
            streetViewControl: false,
            rotateControl: false,
            fullscreenControl: true
        });
        
        // Initialize services
        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
            draggable: false,
            suppressMarkers: false,
            polylineOptions: {
                strokeColor: '#007bff',
                strokeWeight: 4,
                strokeOpacity: 0.8
            }
        });
        directionsRenderer.setMap(map);
        
        // Initialize Places Autocomplete
        initializeGoogleAutocomplete();
        
        console.log('Traditional Google Maps initialized successfully');
        
        // Get user location
        getUserLocationForMap();
        
        // Initialize commute destinations
        setTimeout(() => {
            if (typeof initializeCommuteDestinations === 'function') {
                initializeCommuteDestinations();
            }
        }, 1000);
        
    } catch (error) {
        console.error('Error initializing traditional Google Maps:', error);
        fallbackToLeaflet();
    }
}

// Debug function to check Google Maps availability
function checkGoogleMapsStatus() {
    console.log('=== Google Maps Status Check ===');
    console.log('typeof google:', typeof google);
    console.log('google available:', typeof google !== 'undefined');
    
    if (typeof google !== 'undefined') {
        console.log('google.maps available:', typeof google.maps !== 'undefined');
        if (google.maps) {
            console.log('google.maps.Map available:', typeof google.maps.Map !== 'undefined');
            console.log('google.maps.places available:', typeof google.maps.places !== 'undefined');
            console.log('google.maps.DirectionsService available:', typeof google.maps.DirectionsService !== 'undefined');
        }
    }
    
    console.log('customElements available:', typeof customElements !== 'undefined');
    if (typeof customElements !== 'undefined') {
        console.log('gmp-map defined:', customElements.get('gmp-map') !== undefined);
        console.log('gmp-advanced-marker defined:', customElements.get('gmp-advanced-marker') !== undefined);
    }
    
    console.log('Extended components script loaded:', document.querySelector('script[src*="extended-component-library"]') !== null);
    console.log('Google Maps script present:', document.querySelector('script[src*="maps.googleapis.com"]') !== null);
    console.log('Current map system:', window.useGoogleMaps ? (isWebComponent ? 'Google Maps Web Components' : 'Traditional Google Maps') : 'Leaflet');
    console.log('================================');
    
    // Show user-friendly status
    const statusMessage = getMapSystemStatus();
    console.log('User Status:', statusMessage);
    
    // Show alert to user as well
    // if (typeof showAlert === 'function') {
    //     showAlert(statusMessage, 'info', 5000);
    // }
}

function getMapSystemStatus() {
    if (typeof google !== 'undefined' && google.maps) {
        if (isWebComponent && customElements.get('gmp-map')) {
            return 'Google Maps Web Components are active and working';
        } else if (!isWebComponent) {
            return 'Traditional Google Maps is active and working';
        } else {
            return 'Google Maps API loaded but Web Components not ready';
        }
    } else {
        const gmapsScript = document.querySelector('script[src*="maps.googleapis.com"]');
        if (gmapsScript) {
            return 'Google Maps script found but API not loaded yet - please wait or check network connection';
        } else {
            return 'Google Maps script not found - using Leaflet fallback';
        }
    }
}

// Google Maps callback function - this will be called when API loads
window.initGoogleMaps = function() {
    console.log('Google Maps callback triggered');
    
    // Clear any existing timeouts or intervals
    if (window.googleMapsCheckInterval) {
        clearInterval(window.googleMapsCheckInterval);
        window.googleMapsCheckInterval = null;
    }
    
    // Initialize Google Maps system
    setTimeout(() => {
        console.log('Initializing Google Maps from callback...');
        initializeGoogleMapsSystem();
    }, 100);
};

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing map system...');
    
    // Wait a bit for scripts to settle, then start initialization
    setTimeout(() => {
        initializeMapSystem();
    }, 500);
});

// Main map system initialization function
function initializeMapSystem() {
    console.log('Starting map system initialization...');
    checkGoogleMapsStatus();
    
    // Check if Google Maps is available
    if (typeof google !== 'undefined' && google.maps) {
        console.log('Google Maps API available immediately');
        initializeGoogleMapsSystem();
    } else {
        console.log('Google Maps not available yet, setting up callback system...');
        setupGoogleMapsCallback();
    }
}

// Initialize Google Maps system
function initializeGoogleMapsSystem() {
    window.googleMapsLoaded = true;
    window.useGoogleMaps = true;
    
    // Check if Web Components are available
    if (typeof customElements !== 'undefined' && customElements.get('gmp-map')) {
        console.log('Using Google Maps Web Components');
        isWebComponent = true;
        initWebComponentMap();
    } else {
        console.log('Using traditional Google Maps');
        isWebComponent = false;
        initTraditionalMap();
    }
}

// Setup callback system for Google Maps loading
function setupGoogleMapsCallback() {
    // Check if scripts are present - be more thorough in checking
    const allScripts = document.querySelectorAll('script');
    let gmapsScript = null;
    let extendedScript = null;
    
    // Search through all scripts to find Google Maps and Extended Components
    for (let script of allScripts) {
        if (script.src && script.src.includes('maps.googleapis.com')) {
            gmapsScript = script;
            console.log('Found Google Maps script:', script.src);
        }
        if (script.src && script.src.includes('extended-component-library')) {
            extendedScript = script;
            console.log('Found Extended Components script:', script.src);
        }
    }
    
    // Also check if the Google Maps script is in the process of loading
    const possibleGMapsScript = document.querySelector('script[src*="maps.googleapis.com/maps/api/js"]');
    if (possibleGMapsScript && !gmapsScript) {
        gmapsScript = possibleGMapsScript;
        console.log('Found Google Maps script with specific selector:', gmapsScript.src);
    }
    
    if (!gmapsScript) {
        console.error('Google Maps script not found in DOM! Available scripts:');
        console.log('All script sources:', Array.from(allScripts).map(s => s.src).filter(src => src));
        console.log('Attempting to inject Google Maps script...');
        injectGoogleMapsScript();
        return;
    }
    
    if (!extendedScript) {
        console.warn('Extended Components script not found, will use traditional Google Maps');
        isWebComponent = false;
    }
    
    // Set up a more reliable waiting system
    let waitCount = 0;
    const maxWaits = 30; // Wait up to 30 seconds
    const checkInterval = 1000; // Check every second
    
    const checkGoogleMaps = () => {
        waitCount++;
        console.log(`Checking Google Maps availability... (${waitCount}/${maxWaits})`);
        
        if (typeof google !== 'undefined' && google.maps) {
            console.log('Google Maps API loaded after waiting');
            // Clear the interval
            if (window.googleMapsCheckInterval) {
                clearInterval(window.googleMapsCheckInterval);
                window.googleMapsCheckInterval = null;
            }
            initializeGoogleMapsSystem();
        } else if (waitCount >= maxWaits) {
            console.log('Google Maps failed to load after 30 seconds, falling back to Leaflet');
            if (window.googleMapsCheckInterval) {
                clearInterval(window.googleMapsCheckInterval);
                window.googleMapsCheckInterval = null;
            }
            fallbackToLeaflet();
        }
        // If we haven't reached max waits and Google Maps is not available, 
        // the interval will continue
    };
    
    // Start checking immediately, then set up interval
    checkGoogleMaps();
    
    // Store interval reference for cleanup
    window.googleMapsCheckInterval = setInterval(checkGoogleMaps, checkInterval);
}

// Inject Google Maps script if not found
function injectGoogleMapsScript() {
    console.log('Injecting Google Maps script...');
    
    // Remove any existing broken scripts first
    const existingScripts = document.querySelectorAll('script[src*="maps.googleapis.com"]');
    existingScripts.forEach(script => {
        if (script.parentNode) {
            console.log('Removing existing Google Maps script');
            script.parentNode.removeChild(script);
        }
    });
    
    // Create new script element
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&callback=initGoogleMaps&libraries=places,geometry&v=beta`;
    script.async = true;
    script.defer = true;
    
    // Add error handling
    script.onerror = function() {
        console.error('Injected Google Maps script failed to load, trying fallback');
        tryFallbackGoogleMaps();
    };
    
    script.onload = function() {
        console.log('Injected Google Maps script loaded successfully');
    };
    
    // Append to head
    document.head.appendChild(script);
    console.log('Google Maps script injected, waiting for callback...');
    
    // Set up fallback timer
    setTimeout(() => {
        if (typeof google === 'undefined') {
            console.log('Google Maps still not available after injection, falling back to Leaflet');
            fallbackToLeaflet();
        }
    }, 10000); // Wait 10 seconds max
}

// Handle Google Maps loading errors
window.gm_authFailure = function() {
    console.error('Google Maps authentication failed, falling back to Leaflet');
    window.useGoogleMaps = false;
    fallbackToLeaflet();
};

// Initialize Web Component Map
function initWebComponentMap() {
    try {
        const mapElement = document.getElementById('map');
        
        if (!mapElement) {
            console.error('Map element not found');
            fallbackToLeaflet();
            return;
        }
        
        console.log('Initializing Google Maps Web Component...');
        
        // Wait for the gmp-map element to be defined
        if (typeof customElements !== 'undefined') {
            customElements.whenDefined('gmp-map').then(() => {
                console.log('gmp-map element is ready');
                setupWebComponentMap(mapElement);
            }).catch((error) => {
                console.error('Error waiting for gmp-map element:', error);
                fallbackToLeaflet();
            });
        } else {
            // Fallback if custom elements not supported
            console.log('Custom elements not supported, trying direct setup');
            setTimeout(() => setupWebComponentMap(mapElement), 1000);
        }
        
    } catch (error) {
        console.error('Error initializing Google Maps Web Component:', error);
        window.useGoogleMaps = false;
        fallbackToLeaflet();
    }
}

// Setup the actual Web Component map
function setupWebComponentMap(mapElement) {
    try {
        // The gmp-map element is already defined in HTML, just get reference
        map = mapElement;
        
        // Set initial center to Lagos, Nigeria
        map.center = { lat: 6.5244, lng: 3.3792 };
        map.zoom = 12;
        
        // Get references to marker elements
        userLocationMarker = document.getElementById('user-marker');
        pickupMarker = document.getElementById('pickup-marker');
        dropoffMarker = document.getElementById('dropoff-marker');
        
        // Verify markers exist
        if (!userLocationMarker || !pickupMarker || !dropoffMarker) {
            console.error('Some marker elements not found');
            fallbackToLeaflet();
            return;
        }
        
        // Initialize Google Maps services for directions
        if (typeof google !== 'undefined' && google.maps) {
            directionsService = new google.maps.DirectionsService();
            
            // Initialize Google Places Autocomplete
            initializeGoogleAutocomplete();
        } else {
            console.error('Google Maps services not available');
            fallbackToLeaflet();
            return;
        }
        
        console.log('Google Maps Web Component initialized successfully');
        
        // Immediately get user location and show marker
        getUserLocationForMap();
        
        // Initialize commute destinations after a short delay
        setTimeout(() => {
            if (typeof initializeCommuteDestinations === 'function') {
                initializeCommuteDestinations();
            }
        }, 1000);
        
    } catch (error) {
        console.error('Error setting up Google Maps Web Component:', error);
        fallbackToLeaflet();
    }
}

// Initialize Google Places Autocomplete - Using modern PlaceAutocompleteElement
function initializeGoogleAutocomplete() {
    const pickupInput = document.getElementById('pickup_location');
    const dropoffInput = document.getElementById('dropoff_location');
    
    // Check if the new PlaceAutocompleteElement is available (recommended approach)
    if (typeof google !== 'undefined' && google.maps && google.maps.places && google.maps.places.PlaceAutocompleteElement) {
        console.log('Using new PlaceAutocompleteElement (recommended)');
        initializeModernPlaceAutocomplete(pickupInput, dropoffInput);
    } else if (typeof google !== 'undefined' && google.maps && google.maps.places && google.maps.places.Autocomplete) {
        console.log('Using legacy Autocomplete (deprecated but still supported)');
        initializeLegacyAutocomplete(pickupInput, dropoffInput);
    } else {
        console.warn('Google Places API not available, falling back to basic input handling');
        initializeBasicLocationHandling(pickupInput, dropoffInput);
    }
}

// Modern approach using PlaceAutocompleteElement
function initializeModernPlaceAutocomplete(pickupInput, dropoffInput) {
    try {
        if (pickupInput) {
            // Create the new PlaceAutocompleteElement
            const pickupAutocomplete = new google.maps.places.PlaceAutocompleteElement({
                componentRestrictions: { country: 'ng' },
                fields: ['place_id', 'geometry', 'name', 'formatted_address'],
                types: ['establishment', 'geocode']
            });
            
            // Replace the input with the PlaceAutocompleteElement
            pickupInput.parentNode.insertBefore(pickupAutocomplete, pickupInput);
            pickupInput.style.display = 'none'; // Hide original input
            
            // Set placeholder and styling
            pickupAutocomplete.placeholder = pickupInput.placeholder;
            pickupAutocomplete.className = pickupInput.className;
            pickupAutocomplete.required = pickupInput.required;
            
            pickupAutocomplete.addEventListener('place_changed', () => {
                const place = pickupAutocomplete.place;
                if (place && place.geometry) {
                    document.getElementById('pickup_latitude').value = formatCoordinate(place.geometry.location.lat());
                    document.getElementById('pickup_longitude').value = formatCoordinate(place.geometry.location.lng());
                    
                    // Update the hidden input for form submission
                    pickupInput.value = place.formatted_address || place.name;
                    
                    console.log('Pickup location selected (modern):', {
                        name: place.name,
                        address: place.formatted_address,
                        lat: place.geometry.location.lat(),
                        lng: place.geometry.location.lng()
                    });
                    
                    updateEstimates();
                    updateMapWithRoute();
                    showAlert('Pickup location set successfully', 'success', 2000);
                }
            });
            
            console.log('Modern PlaceAutocompleteElement initialized for pickup');
        }
        
        if (dropoffInput) {
            // Create the new PlaceAutocompleteElement for dropoff
            const dropoffAutocomplete = new google.maps.places.PlaceAutocompleteElement({
                componentRestrictions: { country: 'ng' },
                fields: ['place_id', 'geometry', 'name', 'formatted_address'],
                types: ['establishment', 'geocode']
            });
            
            // Replace the input with the PlaceAutocompleteElement
            dropoffInput.parentNode.insertBefore(dropoffAutocomplete, dropoffInput);
            dropoffInput.style.display = 'none'; // Hide original input
            
            // Set placeholder and styling
            dropoffAutocomplete.placeholder = dropoffInput.placeholder;
            dropoffAutocomplete.className = dropoffInput.className;
            dropoffAutocomplete.required = dropoffInput.required;
            
            dropoffAutocomplete.addEventListener('place_changed', () => {
                const place = dropoffAutocomplete.place;
                if (place && place.geometry) {
                    document.getElementById('dropoff_latitude').value = formatCoordinate(place.geometry.location.lat());
                    document.getElementById('dropoff_longitude').value = formatCoordinate(place.geometry.location.lng());
                    
                    // Update the hidden input for form submission
                    dropoffInput.value = place.formatted_address || place.name;
                    
                    console.log('Dropoff location selected (modern):', {
                        name: place.name,
                        address: place.formatted_address,
                        lat: place.geometry.location.lat(),
                        lng: place.geometry.location.lng()
                    });
                    
                    updateEstimates();
                    updateMapWithRoute();
                    showAlert('Dropoff location set successfully', 'success', 2000);
                }
            });
            
            console.log('Modern PlaceAutocompleteElement initialized for dropoff');
        }
    } catch (error) {
        console.warn('Error initializing modern PlaceAutocompleteElement, falling back to legacy Autocomplete:', error);
        // Fall back to legacy autocomplete if modern approach fails
        initializeLegacyAutocomplete(pickupInput, dropoffInput);
    }
}

// Legacy approach using deprecated Autocomplete (for fallback)
function initializeLegacyAutocomplete(pickupInput, dropoffInput) {
    if (pickupInput) {
        const pickupAutocomplete = new google.maps.places.Autocomplete(pickupInput, {
            componentRestrictions: { country: 'ng' },
            fields: ['place_id', 'geometry', 'name', 'formatted_address'],
            types: ['establishment', 'geocode']
        });
        
        pickupAutocomplete.addListener('place_changed', () => {
            const place = pickupAutocomplete.getPlace();
            if (place.geometry) {
                document.getElementById('pickup_latitude').value = formatCoordinate(place.geometry.location.lat());
                document.getElementById('pickup_longitude').value = formatCoordinate(place.geometry.location.lng());
                
                // Update the input with formatted address
                pickupInput.value = place.formatted_address || place.name;
                
                console.log('Pickup location selected (legacy):', {
                    name: place.name,
                    address: place.formatted_address,
                    lat: place.geometry.location.lat(),
                    lng: place.geometry.location.lng()
                });
                
                updateEstimates();
                updateMapWithRoute();
                showAlert('Pickup location set successfully', 'success', 2000);
            }
        });
        
        console.log('Legacy Google Places Autocomplete initialized for pickup');
    }
    
    if (dropoffInput) {
        const dropoffAutocomplete = new google.maps.places.Autocomplete(dropoffInput, {
            componentRestrictions: { country: 'ng' },
            fields: ['place_id', 'geometry', 'name', 'formatted_address'],
            types: ['establishment', 'geocode']
        });
        
        dropoffAutocomplete.addListener('place_changed', () => {
            const place = dropoffAutocomplete.getPlace();
            if (place.geometry) {
                document.getElementById('dropoff_latitude').value = formatCoordinate(place.geometry.location.lat());
                document.getElementById('dropoff_longitude').value = formatCoordinate(place.geometry.location.lng());
                
                // Update the input with formatted address
                dropoffInput.value = place.formatted_address || place.name;
                
                console.log('Dropoff location selected (legacy):', {
                    name: place.name,
                    address: place.formatted_address,
                    lat: place.geometry.location.lat(),
                    lng: place.geometry.location.lng()
                });
                
                updateEstimates();
                updateMapWithRoute();
                showAlert('Dropoff location set successfully', 'success', 2000);
            }
        });
        
        console.log('Legacy Google Places Autocomplete initialized for dropoff');
    }
}

// Basic fallback for when Google Places API is not available
function initializeBasicLocationHandling(pickupInput, dropoffInput) {
    console.log('Initializing basic location handling fallback');
    // This would use the existing Nigerian cities database and manual geocoding
    // Implementation would go here if needed
}

// Fallback to Leaflet if Google Maps fails
function fallbackToLeaflet() {
    console.log('Initializing Leaflet fallback...');
    
    // Wait for Leaflet to load if not already loaded
    if (typeof L === 'undefined') {
        console.log('Waiting for Leaflet to load...');
        setTimeout(fallbackToLeaflet, 200);
        return;
    }
    
    // Hide the Web Component map and show Leaflet container
    const webComponentMap = document.getElementById('map');
    const leafletMap = document.getElementById('leaflet-map');
    
    if (webComponentMap && leafletMap) {
        webComponentMap.classList.add('d-none');
        leafletMap.classList.remove('d-none');
    }
    
    window.useGoogleMaps = false;
    isWebComponent = false;
    initMap(); // This will call the existing Leaflet initialization
}

// Ensure global variables are always defined
if (typeof window.leafletMarkers === 'undefined') {
    window.leafletMarkers = [];
}
if (typeof window.leafletControl === 'undefined') {
    window.leafletControl = null;
}
if (typeof window.leafletRouteLine === 'undefined') {
    window.leafletRouteLine = null;
}

// Safe routing control cleanup function
function safeRemoveRoutingControl() {
    if (routingControl && map) {
        try {
            // First try to clear waypoints if the method exists
            if (routingControl.getWaypoints && typeof routingControl.getWaypoints === 'function') {
                const waypoints = routingControl.getWaypoints();
                if (waypoints && waypoints.length > 0) {
                    console.log('Clearing waypoints...');
                    routingControl.spliceWaypoints(0, waypoints.length);
                }
            }
            
            // Check if the control is actually on the map before removing
            if (map.hasLayer && map.hasLayer(routingControl)) {
                console.log('Removing routing control from map...');
                map.removeControl(routingControl);
            } else if (routingControl.remove && typeof routingControl.remove === 'function') {
                console.log('Using routing control remove method...');
                routingControl.remove();
            } else {
                console.log('Routing control not found on map or already removed');
            }
            
            console.log('Routing control cleanup completed');
        } catch (e) {
            console.log('Error during routing control cleanup:', e.message);
            // Try alternative cleanup methods
            try {
                if (routingControl._map) {
                    routingControl._map.removeControl(routingControl);
                }
            } catch (e2) {
                console.log('Alternative cleanup also failed:', e2.message);
            }
        } finally {
            routingControl = null;
        }
    }
}

// Debug function to check map state
function debugMapState() {
    console.log('=== Map Debug Info ===');
    console.log('Leaflet available:', typeof L !== 'undefined');
    if (typeof L !== 'undefined') {
        console.log('Leaflet version:', L.version);
        console.log('Leaflet.map available:', typeof L.map === 'function');
        console.log('Leaflet.Routing available:', typeof L.Routing !== 'undefined');
    }
    console.log('Map object:', map);
    
    const mapElement = document.getElementById('map');
    const placeholder = document.getElementById('map-placeholder');
    const container = document.querySelector('.map-container');
    
    console.log('Map element:', mapElement);
    if (mapElement) {
        console.log('Map element display:', window.getComputedStyle(mapElement).display);
        console.log('Map element visibility:', window.getComputedStyle(mapElement).visibility);
        console.log('Map element dimensions:', mapElement.offsetWidth + 'x' + mapElement.offsetHeight);
        console.log('Map element computed size:', window.getComputedStyle(mapElement).width + 'x' + window.getComputedStyle(mapElement).height);
    }
    
    console.log('Map placeholder:', placeholder);
    if (placeholder) {
        console.log('Placeholder display:', window.getComputedStyle(placeholder).display);
        console.log('Placeholder z-index:', window.getComputedStyle(placeholder).zIndex);
    }
    
    console.log('Container element:', container);
    if (container) {
        console.log('Container height:', window.getComputedStyle(container).height);
        console.log('Container position:', window.getComputedStyle(container).position);
    }
    
    if (map) {
        console.log('Map zoom:', map.getZoom());
        console.log('Map center:', map.getCenter());
        try {
            console.log('Map size:', map.getSize());
            console.log('Map container element:', map.getContainer());
        } catch (e) {
            console.log('Error getting map details:', e.message);
        }
    }
    
    console.log('Script elements:', document.querySelectorAll('script[src*="leaflet"]').length);
    console.log('=====================');
}

// Nigerian cities database for location suggestions
const nigerianCities = [
    { name: 'Lagos', state: 'Lagos', lat: 6.5244, lng: 3.3792 },
    { name: 'Abuja', state: 'FCT', lat: 9.0765, lng: 7.3986 },
    { name: 'Kano', state: 'Kano', lat: 12.0022, lng: 8.5920 },
    { name: 'Ibadan', state: 'Oyo', lat: 7.3775, lng: 3.9470 },
    { name: 'Port Harcourt', state: 'Rivers', lat: 4.8156, lng: 7.0498 },
    { name: 'Benin City', state: 'Edo', lat: 6.3350, lng: 5.6037 },
    { name: 'Kaduna', state: 'Kaduna', lat: 10.5222, lng: 7.4383 },
    { name: 'Jos', state: 'Plateau', lat: 9.8965, lng: 8.8583 },
    { name: 'Ilorin', state: 'Kwara', lat: 8.5370, lng: 4.5423 },
    { name: 'Enugu', state: 'Enugu', lat: 6.4434, lng: 7.4981 },
    { name: 'Abeokuta', state: 'Ogun', lat: 7.1475, lng: 3.3619 },
    { name: 'Warri', state: 'Delta', lat: 5.5160, lng: 5.7500 },
    { name: 'Calabar', state: 'Cross River', lat: 4.9516, lng: 8.3220 },
    { name: 'Uyo', state: 'Akwa Ibom', lat: 5.0380, lng: 7.9070 },
    { name: 'Owerri', state: 'Imo', lat: 5.4840, lng: 7.0351 },
    { name: 'Akure', state: 'Ondo', lat: 7.2571, lng: 5.2058 },
    { name: 'Osogbo', state: 'Osun', lat: 7.7719, lng: 4.5567 },
    { name: 'Ado-Ekiti', state: 'Ekiti', lat: 7.6211, lng: 5.2206 },
    { name: 'Ikeja', state: 'Lagos', lat: 6.5955, lng: 3.3364 },
    { name: 'Victoria Island', state: 'Lagos', lat: 6.4281, lng: 3.4219 }
];

// Initialize Leaflet map
function initMap() {
    // Prevent re-initialization if map already exists
    if (map) {
        console.log('Map already initialized');
        return;
    }
    
    // Check if required elements exist - use leaflet-map container when falling back
    const mapElement = isWebComponent ? document.getElementById('leaflet-map') : document.getElementById('map');
    
    if (!mapElement) {
        console.error('Map element not found!');
        return;
    }
    
    try {
        console.log('Initializing Leaflet map...');
        
        // Ensure map container is visible and properly sized
        if (mapElement) {
            mapElement.style.display = 'block';
            mapElement.style.width = '100%';
            mapElement.style.height = '100%';
            mapElement.style.minHeight = '300px';
        }
        
        // Initialize Leaflet map centered on Lagos, Nigeria (fallback)
        const mapId = isWebComponent ? 'leaflet-map' : 'map';
        map = L.map(mapId, {
            preferCanvas: false,
            zoomControl: true,
            attributionControl: true
        }).setView([6.5244, 3.3792], 12);
        
        // Add OpenStreetMap tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);

        // Initialize global Leaflet variables
        window.leafletControl = null;
        window.leafletMarkers = [];
        window.leafletRouteLine = null;
        
        // Initialize routing control as null to prevent errors
        routingControl = null;

        console.log('Leaflet map initialized successfully');
        
        // Force map to resize and invalidate size to ensure proper rendering
        setTimeout(() => {
            if (map) {
                console.log('Invalidating map size and forcing render...');
                map.invalidateSize();
                map._onResize(); // Force resize event
                
                // Try to get user's location after map is fully ready
                getUserLocationForMap();
            }
        }, 100);
        
    } catch (error) {
        console.error('Error initializing map:', error);
        console.log('Map initialization failed, continuing without map');
    }
}

// Get user's location and center map on it
function getUserLocationForMap() {
    if (!map) {
        console.log('Map not ready yet, will try to get location later');
        return;
    }
    
    if ("geolocation" in navigator) {
        showAlert('Locating you on the map...', 'info', 2000);
        
        navigator.geolocation.getCurrentPosition(
            function(position) {
                const userLat = position.coords.latitude;
                const userLng = position.coords.longitude;
                
                console.log('User location found:', { userLat, userLng });
                
                if (window.useGoogleMaps && isWebComponent) {
                    // Web Component implementation
                    map.center = { lat: userLat, lng: userLng };
                    map.zoom = 15;
                    
                    // Show user location marker
                    if (userLocationMarker) {
                        userLocationMarker.position = { lat: userLat, lng: userLng };
                        userLocationMarker.title = 'Your Current Location';
                        userLocationMarker.classList.remove('d-none');
                        
                        // Add click event to marker
                        userLocationMarker.addEventListener('click', () => {
                            showLocationPopup(userLat, userLng);
                        });
                    }
                    
                } else if (window.useGoogleMaps && typeof google !== 'undefined') {
                    // Traditional Google Maps implementation
                    map.setCenter({ lat: userLat, lng: userLng });
                    map.setZoom(15);
                    
                    // Remove existing user location marker if any
                    if (userLocationMarker) {
                        // Check if it's a Google Maps marker
                        if (userLocationMarker.setMap && typeof userLocationMarker.setMap === 'function') {
                            userLocationMarker.setMap(null);
                        } else if (userLocationMarker.remove && typeof userLocationMarker.remove === 'function') {
                            // Leaflet marker cleanup
                            try {
                                map.removeLayer(userLocationMarker);
                            } catch (e) {
                                console.log('Error removing existing marker:', e);
                            }
                        }
                        userLocationMarker = null;
                    }
                    
                    // Add a marker for user's current location
                    userLocationMarker = new google.maps.Marker({
                        position: { lat: userLat, lng: userLng },
                        map: map,
                        title: 'Your Current Location',
                        icon: {
                            url: 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png',
                            scaledSize: new google.maps.Size(32, 32)
                        }
                    });
                    
                    // Create popup content with action button
                    const infoWindow = new google.maps.InfoWindow({
                        content: `
                            <div style="text-align: center;">
                                <strong>Your Current Location</strong><br>
                                <small>GPS coordinates: ${userLat.toFixed(4)}, ${userLng.toFixed(4)}</small><br>
                                <button onclick="useLocationAsPickup(${userLat}, ${userLng})" class="btn btn-sm btn-primary mt-2">
                                    <i class="fas fa-map-marker-alt me-1"></i>Use as Pickup
                                </button>
                            </div>
                        `
                    });
                    
                    userLocationMarker.addListener('click', () => {
                        infoWindow.open(map, userLocationMarker);
                    });
                    
                    // Open info window automatically
                    infoWindow.open(map, userLocationMarker);
                    
                } else {
                    // Leaflet implementation
                    map.setView([userLat, userLng], 15);
                    
                    // Remove existing user location marker if any
                    if (userLocationMarker) {
                        try {
                            // Check if it's a Leaflet marker
                            if (userLocationMarker.remove && typeof userLocationMarker.remove === 'function') {
                                userLocationMarker.remove();
                            } else if (map.removeLayer && typeof map.removeLayer === 'function') {
                                map.removeLayer(userLocationMarker);
                            }
                        } catch (e) {
                            console.log('Error removing existing user location marker:', e);
                        }
                        userLocationMarker = null;
                    }
                    
                    // Add a marker for user's current location
                    userLocationMarker = L.marker([userLat, userLng], {
                        icon: L.divIcon({
                            html: '<i class="fas fa-user-circle text-primary" style="font-size: 24px;"></i>',
                            iconSize: [30, 30],
                            className: 'user-location-marker'
                        })
                    }).addTo(map);
                    
                    // Create popup content with action button
                    const popupContent = `
                        <div class="text-center">
                            <i class="fas fa-map-marker-alt text-primary"></i><br>
                            <strong>Your Current Location</strong><br>
                            <small class="d-block mb-2">GPS coordinates: ${userLat.toFixed(4)}, ${userLng.toFixed(4)}</small>
                            <button class="btn btn-sm btn-primary" onclick="useLocationAsPickup(${userLat}, ${userLng})">
                                <i class="fas fa-map-marker-alt me-1"></i>Use as Pickup
                            </button>
                        </div>
                    `;
                    
                    userLocationMarker.bindPopup(popupContent).openPopup();
                }
                
               //  showAlert('Map centered on your location', 'success', 2000);
                
                // Refresh commute times with user's actual location
                setTimeout(() => {
                    refreshCommuteTimes();
                }, 1000);
            },
            function(error) {
                console.log('Error getting user location:', error.message);
                
                // Show appropriate message based on error type
                switch(error.code) {
                    case error.PERMISSION_DENIED:
                        showAlert('Location access denied. Map shows Lagos area.', 'warning', 3000);
                        break;
                    case error.POSITION_UNAVAILABLE:
                        showAlert('Location unavailable. Map shows Lagos area.', 'warning', 3000);
                        break;
                    case error.TIMEOUT:
                        showAlert('Location request timeout. Map shows Lagos area.', 'warning', 3000);
                        break;
                    default:
                        showAlert('Could not get your location. Map shows Lagos area.', 'warning', 3000);
                        break;
                }
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 300000 // 5 minutes
            }
        );
    } else {
        console.log('Geolocation not supported');
        showAlert('Location services not supported by your browser', 'info', 3000);
    }
}

// Show location popup for Web Components
function showLocationPopup(lat, lng) {
    // Create a simple alert or modal for now
    // In a real implementation, you might want to use a proper modal
    const useLocation = confirm(`Use this location as pickup?\nCoordinates: ${lat.toFixed(4)}, ${lng.toFixed(4)}`);
    if (useLocation) {
        useLocationAsPickup(lat, lng);
    }
}

// Use the user's current location as pickup location
async function useLocationAsPickup(latitude, longitude) {
    try {
        showAlert('Setting current location as pickup...', 'info', 2000);
        
        // Get address from coordinates using reverse geocoding
        const address = await reverseGeocode(latitude, longitude);
        
        // Set the pickup location
        document.getElementById('pickup_location').value = address;
        document.getElementById('pickup_latitude').value = formatCoordinate(latitude);
        document.getElementById('pickup_longitude').value = formatCoordinate(longitude);
        
        // Update estimates and map (only if functions exist)
        if (typeof updateEstimates === 'function') {
            updateEstimates();
        }
        if (typeof updateMapWithRoute === 'function') {
            updateMapWithRoute();
        }
        
        // Close the popup
        if (userLocationMarker) {
            userLocationMarker.closePopup();
        }
        
        showAlert('Pickup location set to your current location', 'success', 2000);
        
    } catch (error) {
        console.error('Error setting pickup location:', error);
        showAlert('Could not set pickup location', 'error', 3000);
    }
}

// Force use Leaflet map
function forceLeafletMap() {
    console.log('User requested to force Leaflet map');
    window.useGoogleMaps = false;
    isWebComponent = false;
    fallbackToLeaflet();
}


// Refresh user location (called by button click)
function refreshUserLocation() {
    if (!map) {
        showAlert('Map is still loading, please wait...', 'info', 2000);
        // Try to initialize map if it's not ready
        if (typeof L !== 'undefined' && L.map) {
            initMap();
            // Try again after a delay
            setTimeout(() => {
                if (map) {
                    getUserLocationForMap();
                }
            }, 1000);
        }
        return;
    }
    
    getUserLocationForMap();
}

// Force initialize map (for testing)
function forceInitMap() {
    console.log('Force initializing map...');
    debugMapState();
    
    if (typeof L === 'undefined') {
        showAlert('Leaflet library not loaded. Check console for errors.', 'error', 5000);
        return;
    }
    
    // Reset map if it exists
    if (map) {
        try {
            // Clean up routing control first with enhanced safety
            safeRemoveRoutingControl();
            
            // Clean up other layers
            map.eachLayer(function(layer) {
                if (layer instanceof L.Polyline && !(layer instanceof L.Marker)) {
                    try {
                        map.removeLayer(layer);
                    } catch (e) {
                        console.log('Error removing layer during reset:', e);
                    }
                }
            });
            
            map.remove();
        } catch (e) {
            console.log('Error removing existing map:', e);
        }
        map = null;
    }
    
    initMap();
    
    // Extra measures to ensure rendering after initialization
    setTimeout(() => {
        if (map) {
            console.log('Forcing map invalidation and resize...');
            map.invalidateSize(true);
            if (map._onResize) {
                map._onResize();
            }
            // Try manual tile refresh
            map.eachLayer(function(layer) {
                if (layer._url) {
                    layer.redraw();
                }
            });
            console.log('Map forced rendering completed');
        }
    }, 500);
}

// Function to fix map rendering issues
function fixMapRendering() {
    console.log('Attempting to fix map rendering...');
    
    if (!map) {
        console.log('No map to fix, initializing...');
        initMap();
        return;
    }
    
    const mapElement = document.getElementById('map');
    
    // Ensure proper visibility
    if (mapElement) {
        mapElement.style.display = 'block';
        mapElement.style.visibility = 'visible';
        mapElement.style.opacity = '1';
        mapElement.style.position = 'relative';
    }
    
    // Force map to recalculate size and redraw
    setTimeout(() => {
        if (map) {
            console.log('Forcing map size recalculation...');
            map.invalidateSize(true);
            
            // Force redraw of all layers
            map.eachLayer(function(layer) {
                if (layer.redraw) {
                    layer.redraw();
                }
            });
            
            console.log('Map rendering fix completed');
            debugMapState();
        }
    }, 100);
}

function updateMapWithRoute() {
    if (!map) {
        console.log('Map not initialized yet, skipping route update');
        return;
    }

    const pickupLat = parseFloat(document.getElementById('pickup_latitude').value);
    const pickupLng = parseFloat(document.getElementById('pickup_longitude').value);
    const dropoffLat = parseFloat(document.getElementById('dropoff_latitude').value);
    const dropoffLng = parseFloat(document.getElementById('dropoff_longitude').value);

    console.log('Updating map with route:', { pickupLat, pickupLng, dropoffLat, dropoffLng });

    if (window.useGoogleMaps && isWebComponent) {
        updateWebComponentRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
    } else if (window.useGoogleMaps && typeof google !== 'undefined') {
        updateGoogleMapRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
    } else {
        updateLeafletMapRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
    }
}

// Update Web Component map with route
function updateWebComponentRoute(pickupLat, pickupLng, dropoffLat, dropoffLng) {
    const validPickup = pickupLat && pickupLng && !isNaN(pickupLat) && !isNaN(pickupLng);
    const validDropoff = dropoffLat && dropoffLng && !isNaN(dropoffLat) && !isNaN(dropoffLng);

    // Hide all markers first
    if (pickupMarker) {
        pickupMarker.classList.add('d-none');
    }
    if (dropoffMarker) {
        dropoffMarker.classList.add('d-none');
    }

    // Show pickup marker
    if (validPickup && pickupMarker) {
        pickupMarker.position = { lat: pickupLat, lng: pickupLng };
        pickupMarker.title = 'Pickup Location';
        pickupMarker.classList.remove('d-none');
    }

    // Show dropoff marker
    if (validDropoff && dropoffMarker) {
        dropoffMarker.position = { lat: dropoffLat, lng: dropoffLng };
        dropoffMarker.title = 'Dropoff Location';
        dropoffMarker.classList.remove('d-none');
    }

    // Center map on markers
    if (validPickup && validDropoff) {
        // Center map between pickup and dropoff
        const centerLat = (pickupLat + dropoffLat) / 2;
        const centerLng = (pickupLng + dropoffLng) / 2;
        map.center = { lat: centerLat, lng: centerLng };
        map.zoom = 13;
        
        // Calculate route using Directions API for distance/duration
        if (directionsService) {
            const request = {
                origin: { lat: pickupLat, lng: pickupLng },
                destination: { lat: dropoffLat, lng: dropoffLng },
                travelMode: google.maps.TravelMode.DRIVING,
                unitSystem: google.maps.UnitSystem.METRIC,
                region: 'NG'
            };
            
            directionsService.route(request, (result, status) => {
                if (status === 'OK') {
                    const route = result.routes[0];
                    const leg = route.legs[0];
                    
                    // Update ride info with Google's data
                    updateRideInfo(leg.distance.text, leg.duration.text);
                    
                    // Calculate fare
                    const distanceKm = leg.distance.value / 1000;
                    
                    // Check if FARE_CONFIG is properly initialized
                    if (typeof FARE_CONFIG === 'undefined' || !FARE_CONFIG.base_fare) {
                        console.warn('FARE_CONFIG not ready in Web Component route calculation, using default values');
                        const baseFare = 100; // Default fallback
                        const perKmRate = 50; // Default fallback
                        const estimatedFare = baseFare + (distanceKm * perKmRate);
                        document.getElementById('estimated-fare').textContent = `â‚¦${estimatedFare.toFixed(2)}`;
                    } else {
                        const baseFare = FARE_CONFIG.base_fare;
                        const perKmRate = FARE_CONFIG.per_km_rate;
                        const estimatedFare = baseFare + (distanceKm * perKmRate);
                        document.getElementById('estimated-fare').textContent = `${FARE_CONFIG.currency_symbol}${estimatedFare.toFixed(2)}`;
                    }
                    showAlert('Route calculated successfully', 'success', 2000);
                } else {
                    console.error('Directions request failed:', status);
                    showAlert('Unable to calculate route', 'warning', 3000);
                }
            });
        }
    } else if (validPickup) {
        map.center = { lat: pickupLat, lng: pickupLng };
        map.zoom = 15;
    } else if (validDropoff) {
        map.center = { lat: dropoffLat, lng: dropoffLng };
        map.zoom = 15;
    }
}

// Update Google Maps with route
function updateGoogleMapRoute(pickupLat, pickupLng, dropoffLat, dropoffLng) {
    // Clear existing markers
    if (pickupMarker) {
        pickupMarker.setMap(null);
        pickupMarker = null;
    }
    if (dropoffMarker) {
        dropoffMarker.setMap(null);
        dropoffMarker = null;
    }
    
    // Clear existing route
    if (directionsRenderer) {
        directionsRenderer.setDirections({ routes: [] });
    }

    const validPickup = pickupLat && pickupLng && !isNaN(pickupLat) && !isNaN(pickupLng);
    const validDropoff = dropoffLat && dropoffLng && !isNaN(dropoffLat) && !isNaN(dropoffLng);

    // Add pickup marker
    if (validPickup) {
        pickupMarker = new google.maps.Marker({
            position: { lat: pickupLat, lng: pickupLng },
            map: map,
            title: 'Pickup Location',
            icon: {
                url: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png',
                scaledSize: new google.maps.Size(32, 32)
            }
        });
        
        const pickupInfoWindow = new google.maps.InfoWindow({
            content: '<strong>Pickup Location</strong><br>' + document.getElementById('pickup_location').value
        });
        
        pickupMarker.addListener('click', () => {
            pickupInfoWindow.open(map, pickupMarker);
        });
    }

    // Add dropoff marker
    if (validDropoff) {
        dropoffMarker = new google.maps.Marker({
            position: { lat: dropoffLat, lng: dropoffLng },
            map: map,
            title: 'Dropoff Location',
            icon: {
                url: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png',
                scaledSize: new google.maps.Size(32, 32)
            }
        });
        
        const dropoffInfoWindow = new google.maps.InfoWindow({
            content: '<strong>Dropoff Location</strong><br>' + document.getElementById('dropoff_location').value
        });
        
        dropoffMarker.addListener('click', () => {
            dropoffInfoWindow.open(map, dropoffMarker);
        });
    }

    // Create route if both points exist
    if (validPickup && validDropoff) {
        const request = {
            origin: { lat: pickupLat, lng: pickupLng },
            destination: { lat: dropoffLat, lng: dropoffLng },
            travelMode: google.maps.TravelMode.DRIVING,
            unitSystem: google.maps.UnitSystem.METRIC,
            avoidHighways: false,
            avoidTolls: false,
            region: 'NG' // Focus on Nigeria
        };
        
        console.log('Calculating Google Maps route...', request);
        
        directionsService.route(request, (result, status) => {
            if (status === 'OK') {
                directionsRenderer.setDirections(result);
                
                // Calculate and display route info using Google's data
                const route = result.routes[0];
                const leg = route.legs[0];
                
                // Use Google's precise distance and duration
                const distance = leg.distance.text;
                const duration = leg.duration.text;
                const distanceMeters = leg.distance.value;
                const durationSeconds = leg.duration.value;
                
                // Update ride info with Google's data
                updateRideInfo(distance, duration);
                
                // Calculate fare using precise distance
                const distanceKm = distanceMeters / 1000;
                
                // Check if FARE_CONFIG is properly initialized
                if (typeof FARE_CONFIG === 'undefined' || !FARE_CONFIG.base_fare) {
                    console.warn('FARE_CONFIG not ready in Google Maps route calculation, using default values');
                    const baseFare = 100; // Default fallback
                    const perKmRate = 50; // Default fallback
                    const estimatedFare = baseFare + (distanceKm * perKmRate);
                    document.getElementById('estimated-fare').textContent = `â‚¦${estimatedFare.toFixed(2)}`;
                } else {
                    const baseFare = FARE_CONFIG.base_fare; // Base fare from backend
                    const perKmRate = FARE_CONFIG.per_km_rate; // Rate per km from backend
                    const estimatedFare = baseFare + (distanceKm * perKmRate);
                    document.getElementById('estimated-fare').textContent = `${FARE_CONFIG.currency_symbol}${estimatedFare.toFixed(2)}`;
                }
                
                console.log('Google Maps route calculated successfully:', {
                    distance: distance,
                    duration: duration,
                    distanceMeters: distanceMeters,
                    durationSeconds: durationSeconds,
                    estimatedFare: `${FARE_CONFIG.currency_symbol}${estimatedFare.toFixed(2)}`
                });
                
                showAlert('Route calculated using Google Maps', 'success', 2000);
            } else {
                console.error('Google Directions request failed:', status);
                
                // Provide specific error messages
                let errorMessage = 'Unable to calculate route';
                switch(status) {
                    case 'ZERO_RESULTS':
                        errorMessage = 'No route found between these locations';
                        break;
                    case 'OVER_QUERY_LIMIT':
                        errorMessage = 'Too many requests. Please try again later';
                        break;
                    case 'REQUEST_DENIED':
                        errorMessage = 'Route request denied';
                        break;
                    case 'INVALID_REQUEST':
                        errorMessage = 'Invalid location data';
                        break;
                    case 'UNKNOWN_ERROR':
                        errorMessage = 'Server error. Please try again';
                        break;
                }
                
                showAlert(errorMessage, 'warning', 3000);
                
                // Fallback to straight line distance calculation using the function parameters
                const distance = calculateDistance(pickupLat, pickupLng, dropoffLat, dropoffLng);
                const duration = Math.round(distance * 2.5); // Rough estimate: 2.5 minutes per km
                updateRideInfo(distance.toFixed(2) + ' km', duration + ' min');
                
                // Center map to show both markers
                const bounds = new google.maps.LatLngBounds();
                if (pickupMarker) bounds.extend(pickupMarker.getPosition());
                if (dropoffMarker) bounds.extend(dropoffMarker.getPosition());
                map.fitBounds(bounds);
                
                console.log('Using fallback distance calculation');
            }
        });
    } else if (validPickup) {
        // Only pickup location available, center map on it
        map.setCenter({ lat: pickupLat, lng: pickupLng });
        map.setZoom(15);
    } else if (validDropoff) {
        // Only dropoff location available, center map on it
        map.setCenter({ lat: dropoffLat, lng: dropoffLng });
        map.setZoom(15);
    }
}

// Update Leaflet map with route (existing functionality)
function updateLeafletMapRoute(pickupLat, pickupLng, dropoffLat, dropoffLng) {
    // Verify map is fully ready
    if (!map.getContainer || !map.getContainer() || !map.getSize()) {
        console.log('Leaflet map container not ready, deferring route update');
        setTimeout(() => updateLeafletMapRoute(pickupLat, pickupLng, dropoffLat, dropoffLng), 500);
        return;
    }

    // Clear existing markers and routes with enhanced error handling
    if (pickupMarker) {
        try {
            map.removeLayer(pickupMarker);
        } catch (e) {
            console.log('Error removing pickup marker:', e);
        }
        pickupMarker = null;
    }
    if (dropoffMarker) {
        try {
            map.removeLayer(dropoffMarker);
        } catch (e) {
            console.log('Error removing dropoff marker:', e);
        }
        dropoffMarker = null;
    }
    
    // Use safe routing control removal
    safeRemoveRoutingControl();

    const validPickup = pickupLat && pickupLng && !isNaN(pickupLat) && !isNaN(pickupLng);
    const validDropoff = dropoffLat && dropoffLng && !isNaN(dropoffLat) && !isNaN(dropoffLng);

    // Add pickup marker
    if (validPickup) {
        pickupMarker = L.marker([pickupLat, pickupLng], {
            icon: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        }).addTo(map);
        
        pickupMarker.bindPopup('<strong>Pickup Location</strong><br>' + document.getElementById('pickup_location').value);
    }

    // Add dropoff marker
    if (validDropoff) {
        dropoffMarker = L.marker([dropoffLat, dropoffLng], {
            icon: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        }).addTo(map);
        
        dropoffMarker.bindPopup('<strong>Dropoff Location</strong><br>' + document.getElementById('dropoff_location').value);
    }

    // Create route if both points exist
    if (validPickup && validDropoff) {
        if (typeof L.Routing !== 'undefined') {
            try {
                // Create routing control with enhanced error handling
                routingControl = L.Routing.control({
                    waypoints: [
                        L.latLng(pickupLat, pickupLng),
                        L.latLng(dropoffLat, dropoffLng)
                    ],
                    routeWhileDragging: false,
                    addWaypoints: false,
                    createMarker: function() { return null; }, // We handle markers ourselves
                    lineOptions: {
                        styles: [{ color: '#007bff', weight: 4, opacity: 0.7 }]
                    },
                    show: false, // Don't show the routing instructions panel
                    draggableWaypoints: false,
                    fitSelectedRoutes: true,
                    autoRoute: true,
                    timeout: 10000 // 10 second timeout
                }).on('routesfound', function(e) {
                    try {
                        const routes = e.routes;
                        if (routes && routes.length > 0) {
                            const summary = routes[0].summary;
                            
                            // Update distance and duration info
                            const distance = (summary.totalDistance / 1000).toFixed(2); // Convert to km
                            const duration = Math.round(summary.totalTime / 60); // Convert to minutes
                            
                            updateRideInfo(distance + ' km', duration + ' min');
                            
                            console.log('Leaflet route calculated successfully:', {
                                distance: distance + ' km',
                                duration: duration + ' min'
                            });
                        }
                    } catch (routeError) {
                        console.error('Error processing route results:', routeError);
                        addFallbackRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
                    }
                }).on('routingerror', function(e) {
                    console.error('Routing error:', e.error);
                    // Fallback to straight line if routing fails
                    addFallbackRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
                }).on('routingstart', function() {
                    console.log('Leaflet routing started...');
                });
                
                // Add to map with comprehensive error handling
                try {
                    if (map && map.getContainer()) {
                        routingControl.addTo(map);
                        console.log('Leaflet routing control added to map successfully');
                    } else {
                        throw new Error('Map not ready for routing');
                    }
                } catch (routingError) {
                    console.error('Error adding routing control to map:', routingError);
                    routingControl = null; // Reset to prevent future errors
                    addFallbackRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
                }
            } catch (error) {
                console.error('Error creating routing control:', error);
                routingControl = null; // Reset to prevent future errors
                addFallbackRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
            }
        } else {
            console.log('Leaflet Routing Machine not available, using fallback');
            // Fallback: draw straight line and calculate distance
            addFallbackRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
        }
    } else if (validPickup) {
        // Only pickup location available, center map on it
        map.setView([pickupLat, pickupLng], 15);
    } else if (validDropoff) {
        // Only dropoff location available, center map on it
        map.setView([dropoffLat, dropoffLng], 15);
    }
}

// Helper function for fallback route display
function addFallbackRoute(pickupLat, pickupLng, dropoffLat, dropoffLng) {
        try {
            map.removeLayer(pickupMarker);
        } catch (e) {
            console.log('Error removing pickup marker:', e);
        }
        pickupMarker = null;
    }
    if (dropoffMarker) {
        try {
            map.removeLayer(dropoffMarker);
        } catch (e) {
            console.log('Error removing dropoff marker:', e);
        }
        dropoffMarker = null;
    }
    
    // Use safe routing control removal
    safeRemoveRoutingControl();

    const validPickup = pickupLat && pickupLng && !isNaN(pickupLat) && !isNaN(pickupLng);
    const validDropoff = dropoffLat && dropoffLng && !isNaN(dropoffLat) && !isNaN(dropoffLng);

    // Add pickup marker
    if (validPickup) {
        pickupMarker = L.marker([pickupLat, pickupLng], {
            icon: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        }).addTo(map);
        
        pickupMarker.bindPopup('<strong>Pickup Location</strong><br>' + document.getElementById('pickup_location').value);
    }

    // Add dropoff marker
    if (validDropoff) {
        dropoffMarker = L.marker([dropoffLat, dropoffLng], {
            icon: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        }).addTo(map);
        
        dropoffMarker.bindPopup('<strong>Dropoff Location</strong><br>' + document.getElementById('dropoff_location').value);
    }

    // Create route if both points exist
    if (validPickup && validDropoff) {
        if (typeof L.Routing !== 'undefined') {
            try {
                // Create routing control with enhanced error handling
                routingControl = L.Routing.control({
                    waypoints: [
                        L.latLng(pickupLat, pickupLng),
                        L.latLng(dropoffLat, dropoffLng)
                    ],
                    routeWhileDragging: false,
                    addWaypoints: false,
                    createMarker: function() { return null; }, // We handle markers ourselves
                    lineOptions: {
                        styles: [{ color: '#007bff', weight: 4, opacity: 0.7 }]
                    },
                    show: false, // Don't show the routing instructions panel
                    draggableWaypoints: false,
                    fitSelectedRoutes: true,
                    autoRoute: true,
                    timeout: 10000 // 10 second timeout
                }).on('routesfound', function(e) {
                    try {
                        const routes = e.routes;
                        if (routes && routes.length > 0) {
                            const summary = routes[0].summary;
                            
                            // Update distance and duration info
                            const distance = (summary.totalDistance / 1000).toFixed(2); // Convert to km
                            const duration = Math.round(summary.totalTime / 60); // Convert to minutes
                            
                            updateRideInfo(distance + ' km', duration + ' min');
                            
                            console.log('Route calculated successfully:', {
                                distance: distance + ' km',
                                duration: duration + ' min'
                            });
                        }
                    } catch (routeError) {
                        console.error('Error processing route results:', routeError);
                        addFallbackRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
                    }
                }).on('routingerror', function(e) {
                    console.error('Routing error:', e.error);
                    // Fallback to straight line if routing fails
                    addFallbackRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
                }).on('routingstart', function() {
                    console.log('Routing started...');
                });
                
                // Add to map with comprehensive error handling
                try {
                    if (map && map.getContainer()) {
                        routingControl.addTo(map);
                        console.log('Routing control added to map successfully');
                    } else {
                        throw new Error('Map not ready for routing');
                    }
                } catch (routingError) {
                    console.error('Error adding routing control to map:', routingError);
                    routingControl = null; // Reset to prevent future errors
                    addFallbackRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
                }
            } catch (error) {
                console.error('Error creating routing control:', error);
                routingControl = null; // Reset to prevent future errors
                addFallbackRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
            }
        } else {
            console.log('Leaflet Routing Machine not available, using fallback');
            // Fallback: draw straight line and calculate distance
            addFallbackRoute(pickupLat, pickupLng, dropoffLat, dropoffLng);
        }
    } else if (validPickup) {
        // Only pickup location available, center map on it
        map.setView([pickupLat, pickupLng], 15);
    } else if (validDropoff) {
        // Only dropoff location available, center map on it
        map.setView([dropoffLat, dropoffLng], 15);
    }


// Helper function for fallback route display
function addFallbackRoute(pickupLat, pickupLng, dropoffLat, dropoffLng) {
    try {
        // Remove any existing polylines first
        map.eachLayer(function(layer) {
            if (layer instanceof L.Polyline && !(layer instanceof L.Marker)) {
                try {
                    map.removeLayer(layer);
                } catch (e) {
                    console.log('Error removing polyline layer:', e);
                }
            }
        });
        
        const latlngs = [[pickupLat, pickupLng], [dropoffLat, dropoffLng]];
        const polyline = L.polyline(latlngs, {
            color: '#007bff',
            weight: 4,
            opacity: 0.7,
            dashArray: '10, 5'
        }).addTo(map);
        
        // Calculate straight-line distance
        const distance = calculateDistance(pickupLat, pickupLng, dropoffLat, dropoffLng);
        const duration = Math.round(distance * 2.5); // Rough estimate: 2.5 minutes per km
        
        updateRideInfo(distance.toFixed(2) + ' km', duration + ' min');
        
        // Fit map to show both markers
        if (pickupMarker && dropoffMarker) {
            try {
                const group = new L.featureGroup([pickupMarker, dropoffMarker]);
                map.fitBounds(group.getBounds().pad(0.1));
            } catch (e) {
                console.log('Error fitting bounds:', e);
                // Fallback: center between points
                const centerLat = (pickupLat + dropoffLat) / 2;
                const centerLng = (pickupLng + dropoffLng) / 2;
                map.setView([centerLat, centerLng], 12);
            }
        }
        
        console.log('Fallback route calculated using straight line distance');
    } catch (error) {
        console.error('Error creating fallback route:', error);
        // Last resort: just update distance info without map route
        const distance = calculateDistance(pickupLat, pickupLng, dropoffLat, dropoffLng);
        const duration = Math.round(distance * 2.5);
        updateRideInfo(distance.toFixed(2) + ' km', duration + ' min');
    }
}

function updateRideInfo(distance, duration) {
    // Update the distance and duration display
    document.getElementById('estimated-distance').textContent = distance;
    document.getElementById('estimated-duration').textContent = duration;

    // Calculate estimated fare based on distance
    // Handle both Google Maps format (e.g., "5.2 km") and numeric values
    let distanceValue;
    if (typeof distance === 'string') {
        distanceValue = parseFloat(distance.replace(/[^\d.]/g, ''));
    } else {
        distanceValue = parseFloat(distance);
    }
    
    if (isNaN(distanceValue) || distanceValue <= 0) {
        document.getElementById('estimated-fare').textContent = '--';
        return;
    }
    
    // Check if FARE_CONFIG is properly initialized
    if (typeof FARE_CONFIG === 'undefined' || !FARE_CONFIG.base_fare) {
        console.warn('FARE_CONFIG not ready in updateRideInfo, using default values');
        const baseFare = 100; // Default fallback
        const perKmRate = 50; // Default fallback
        const estimatedFare = baseFare + (distanceValue * perKmRate);
        
        document.getElementById('estimated-fare').textContent = `â‚¦${estimatedFare.toFixed(2)}`;
    } else {
        const baseFare = FARE_CONFIG.base_fare; // Base fare from backend
        const perKmRate = FARE_CONFIG.per_km_rate; // Rate per km from backend
        const estimatedFare = baseFare + (distanceValue * perKmRate);
        
        document.getElementById('estimated-fare').textContent = `${FARE_CONFIG.currency_symbol}${estimatedFare.toFixed(2)}`;
    }
    
    console.log('Ride info updated:', {
        distance: distance,
        duration: duration,
        distanceValue: distanceValue,
        estimatedFare: `â‚¦${estimatedFare.toFixed(2)}`
    });
}

document.addEventListener('DOMContentLoaded', function() {
    // Redirect if not authenticated
    if (!isAuthenticated()) {
        showAlert('Please login to request a ride', 'warning');
        setTimeout(() => {
            window.location.href = '/login/';
        }, 2000);
        return;
    }

    // Load current fare information from backend
    loadFareInfo();

    // Initialize the map system (Google Maps or Leaflet fallback)
    if (!window.googleMapsLoaded && !window.useGoogleMaps) {
        // Google Maps not loaded yet, wait for it or fallback to Leaflet
        console.log('Waiting for Google Maps or falling back to Leaflet...');
        setTimeout(() => {
            if (!window.googleMapsLoaded) {
                console.log('Google Maps not loaded, falling back to Leaflet');
                fallbackToLeaflet();
                
                // Setup manual location suggestions for Leaflet fallback
                setupLocationSuggestions('pickup');
                setupLocationSuggestions('dropoff');
            }
        }, 3000); // Wait 3 seconds for Google Maps to load
    } else if (window.googleMapsLoaded && window.useGoogleMaps) {
        // Google Maps already loaded
        initializeMapSystem();
    }

    // Ensure required functions are available
    if (typeof makeAuthenticatedRequest === 'undefined') {
        console.error('makeAuthenticatedRequest function not found. Please check if auth.js is loaded properly.');
        showAlert('Authentication system not ready. Please refresh the page.', 'error', 5000);
        return;
    }

    // Check authentication status before setting up form
    if (!isAuthenticated()) {
        console.warn('User is not authenticated');
        showAlert('Please login to request a ride', 'warning');
        setTimeout(() => {
            window.location.href = '/login/';
        }, 2000);
        return;
    }

    // Log authentication details for debugging
    const token = localStorage.getItem('access_token');
    const refreshToken = localStorage.getItem('refresh_token');
    console.log('ðŸ” Authentication status:', {
        hasAccessToken: !!token,
        hasRefreshToken: !!refreshToken,
        tokenLength: token ? token.length : 0,
        isAuthenticated: isAuthenticated()
    });

    if (token) {
        try {
            const payload = JSON.parse(atob(token.split('.')[1]));
            console.log('ðŸ” Token payload:', {
                exp: payload.exp,
                currentTime: Date.now() / 1000,
                isExpired: payload.exp <= Date.now() / 1000,
                user_id: payload.user_id,
                username: payload.username
            });
        } catch (e) {
            console.error('ðŸ” Error parsing token:', e);
        }
    }

    // Set up form submission with error handling
    const rideForm = document.getElementById('ride-request-form');
    if (rideForm) {
        console.log('âœ… Setting up ride request form submission handler');
        
        // Primary event handler with proper error handling
        rideForm.addEventListener('submit', function(e) {
            console.log('âœ… Form submit event triggered via addEventListener');
            e.preventDefault();
            e.stopPropagation();
            console.log('âš ï¸ Form submission prevented - use the button instead');
            safeShowAlert('Please use the "Request Ride" button to submit your request.', 'info', 3000);
        });
        
        // Backup event handler that always prevents default submission
        rideForm.onsubmit = function(e) {
            console.log('âœ… Form onsubmit event triggered (backup handler)');
            e.preventDefault();
            e.stopPropagation();
            console.log('âš ï¸ Form submission prevented - use the button instead');
            return false; // Always prevent default form submission
        };
        
        console.log('âœ… Form event handlers set up successfully');
        
        // Run diagnostic checks
        runDiagnosticChecks();
    } else {
        console.error('âŒ Ride request form not found!');
    }
    
    // Set up ride type radio button listeners
    document.getElementById('immediate').addEventListener('change', handleRideTypeChange);
    document.getElementById('scheduled').addEventListener('change', handleRideTypeChange);
    
    // Set minimum datetime for scheduled rides (30 minutes from now)
    const now = new Date();
    now.setMinutes(now.getMinutes() + 30);
    document.getElementById('scheduled_pickup_time').min = now.toISOString().slice(0, 16);

    // Close suggestions when clicking outside (only for non-Google Maps)
    document.addEventListener('click', function(e) {
        if (!window.useGoogleMaps && !e.target.closest('.input-group')) {
            hideSuggestions('pickup');
            hideSuggestions('dropoff');
        }
    });
});

// Load current fare information from backend
async function loadFareInfo() {
    try {
        console.log('ðŸ·ï¸ Loading fare information from backend...');
        const response = await makeAuthenticatedRequest('/api/fare-info/');
        
        if (response.ok) {
            FARE_CONFIG = await response.json();
            console.log('ðŸ·ï¸ Fare info loaded:', FARE_CONFIG);
            
            // Update any displayed fare info if elements exist
            updateFareDisplay();
        } else {
            console.warn('ðŸ·ï¸ Failed to load fare info, using defaults');
        }
    } catch (error) {
        console.error('ðŸ·ï¸ Error loading fare info:', error);
        console.log('ðŸ·ï¸ Using default fare configuration');
    }
}

// Update fare display elements if they exist
function updateFareDisplay() {
    // Check if FARE_CONFIG is properly initialized
    if (typeof FARE_CONFIG !== 'undefined' && FARE_CONFIG.base_fare) {
        console.log(`ðŸ·ï¸ Current fare: ${FARE_CONFIG.currency_symbol}${FARE_CONFIG.base_fare} base + ${FARE_CONFIG.currency_symbol}${FARE_CONFIG.per_km_rate}/km`);
    } else {
        console.log('ðŸ·ï¸ FARE_CONFIG not ready for display update');
    }
}

// Safe alert function that works even if main showAlert fails
function safeShowAlert(message, type = 'info', duration = 5000) {
    try {
        // Try to use the main showAlert function
        if (typeof showAlert === 'function') {
            showAlert(message, type, duration);
            return;
        }
    } catch (error) {
        console.log('Main showAlert failed, using fallback:', error);
    }
    
    // Fallback to browser alert or console
    console.log(`ALERT [${type.toUpperCase()}]: ${message}`);
    
    // Try to create a simple alert container if it doesn't exist
    try {
        let alertContainer = document.getElementById('alert-container');
        if (!alertContainer) {
            alertContainer = document.createElement('div');
            alertContainer.id = 'alert-container';
            alertContainer.className = 'position-fixed';
            alertContainer.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
            document.body.appendChild(alertContainer);
        }
        
        const alertId = 'alert-' + Date.now();
        const typeClass = type === 'danger' ? 'alert-danger' : `alert-${type}`;
        const alertHTML = `
            <div class="${typeClass} alert alert-dismissible fade show" role="alert" id="${alertId}">
                ${message}
                <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
            </div>
        `;
        
        alertContainer.insertAdjacentHTML('beforeend', alertHTML);
        
        // Auto-dismiss
        if (duration > 0) {
            setTimeout(() => {
                const alertElement = document.getElementById(alertId);
                if (alertElement) {
                    alertElement.remove();
                }
            }, duration);
        }
    } catch (e) {
        // Last resort: browser alert
        console.error('All alert methods failed, using browser alert:', e);
        alert(`${type.toUpperCase()}: ${message}`);
    }
}

// Diagnostic function to check if all required functions are available
function runDiagnosticChecks() {
    console.log('ðŸ” Running diagnostic checks...');
    
    const requiredFunctions = [
        'isAuthenticated',
        'makeAuthenticatedRequest', 
        'validateRideForm',
        'formatCoordinate',
        'getCookie',
        'getUserType',
        'getUserEmail'
    ];
    
    const missingFunctions = [];
    const availableFunctions = [];
    
    requiredFunctions.forEach(funcName => {
        if (typeof window[funcName] === 'function') {
            availableFunctions.push(funcName);
        } else {
            missingFunctions.push(funcName);
        }
    });
    
    console.log('âœ… Available functions:', availableFunctions);
    if (missingFunctions.length > 0) {
        console.error('âŒ Missing functions:', missingFunctions);
        safeShowAlert(`Missing required functions: ${missingFunctions.join(', ')}. Please check if auth.js is loaded.`, 'warning', 8000);
    } else {
        console.log('âœ… All required functions are available');
    }
    
    // Check if alert container exists
    const alertContainer = document.getElementById('alert-container');
    if (alertContainer) {
        console.log('âœ… Alert container found');
    } else {
        console.warn('âš ï¸ Alert container not found');
    }
    
    // Test authentication status
    try {
        const authStatus = isAuthenticated();
        console.log('ðŸ” Authentication status:', authStatus);
        if (!authStatus) {
            console.warn('âš ï¸ User is not authenticated');
        }
    } catch (e) {
        console.error('âŒ Error checking authentication status:', e);
    }
}

// Handle ride request button click (bypasses form submission)
function handleRideRequestClick(e) {
    console.log('ðŸš— Ride request button clicked');
    
    // Get the form element
    const form = document.getElementById('ride-request-form');
    if (!form) {
        console.error('âŒ Form not found');
        safeShowAlert('Form not found. Please refresh the page.', 'danger');
        return;
    }
    
    // Create a synthetic event object for compatibility
    const syntheticEvent = {
        type: 'click',
        target: form,
        preventDefault: () => { console.log('preventDefault called (synthetic)'); },
        stopPropagation: () => { console.log('stopPropagation called (synthetic)'); }
    };
    
    // Call the actual handler
    handleRideRequest(syntheticEvent);
}

async function handleRideRequest(e) {
    console.log('ðŸš— handleRideRequest called with event:', e);
    console.log('ðŸš— Event type:', e.type);
    console.log('ðŸš— Event target:', e.target);
    
    e.preventDefault();
    e.stopPropagation(); // Prevent event bubbling
    
    console.log('ðŸš— Form submission started - default prevented');
    
    const submitBtn = document.getElementById('submit-btn');
    const submitText = document.getElementById('submit-text');
    const submitSpinner = document.getElementById('submit-spinner');
    
    // Check if required elements exist
    if (!submitBtn || !submitText || !submitSpinner) {
        console.error('âŒ Required form elements not found');
        safeShowAlert('Form elements missing. Please refresh the page.', 'danger');
        return;
    }
    
    // Validate form
    if (!validateRideForm()) {
        console.log('âŒ Form validation failed');
        return;
    }
    
    // Show loading state
    submitText.textContent = 'Requesting Ride...';
    submitSpinner.classList.remove('d-none');
    submitBtn.disabled = true;
    
    try {
        const formData = new FormData(e.target);
        const isScheduled = formData.get('ride_type') === 'scheduled';
        
        console.log('ðŸš— Form data extracted:', {
            pickup_location: formData.get('pickup_location'),
            pickup_latitude: formData.get('pickup_latitude'),
            pickup_longitude: formData.get('pickup_longitude'),
            dropoff_location: formData.get('dropoff_location'),
            dropoff_latitude: formData.get('dropoff_latitude'),
            dropoff_longitude: formData.get('dropoff_longitude'),
            ride_type: formData.get('ride_type'),
            payment_method: formData.get('payment_method'),
            scheduled_pickup_time: formData.get('scheduled_pickup_time'),
            notes: formData.get('notes')
        });
        
        const rideData = {
            pickup_location: formData.get('pickup_location'),
            pickup_latitude: formatCoordinate(formData.get('pickup_latitude')),
            pickup_longitude: formatCoordinate(formData.get('pickup_longitude')),
            dropoff_location: formData.get('dropoff_location'),
            dropoff_latitude: formatCoordinate(formData.get('dropoff_latitude')),
            dropoff_longitude: formatCoordinate(formData.get('dropoff_longitude')),
            is_scheduled: isScheduled,
            scheduled_pickup_time: isScheduled ? formData.get('scheduled_pickup_time') : null,
            payment_method: formData.get('payment_method'),
            notes: formData.get('notes') || ''
        };
        
        console.log('ðŸš— Sending ride data:', rideData);
        
        // Safety check for makeAuthenticatedRequest function
        if (typeof makeAuthenticatedRequest === 'undefined') {
            throw new Error('Authentication system not ready. Please refresh the page.');
        }

        // Double-check authentication before making request
        if (!isAuthenticated()) {
            throw new Error('You are not logged in. Please login first.');
        }

        console.log('ðŸš— Making authenticated request to /api/...');
        
        // Debug: Show what headers will be sent
        const token = localStorage.getItem('access_token');
        console.log('ðŸš— Request headers will include:', {
            'Authorization': `Bearer ${token ? token.substring(0, 20) + '...' : 'NO_TOKEN'}`,
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken') ? 'PRESENT' : 'MISSING'
        });
        
        const response = await makeAuthenticatedRequest('/api/', {
            method: 'POST',
            body: JSON.stringify(rideData)
        });
        
        console.log('ðŸš— API response received:', {
            status: response.status,
            statusText: response.statusText,
            ok: response.ok,
            headers: Object.fromEntries(response.headers.entries())
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log('Success response:', result);
            document.getElementById('ride-id').textContent = result.id;
            
            // Show success modal
            const modal = new bootstrap.Modal(document.getElementById('success-modal'));
            modal.show();
            
            // Reset form
            e.target.reset();
            clearEstimates();
            
        } else {
            const errorText = await response.text();
            console.log('ðŸš— Error response text:', errorText);
            
            // Handle specific HTTP status codes
                if (response.status === 401) {
                console.error('ðŸš— Authentication failed (401)');
                console.log('ðŸš— Response headers:', Object.fromEntries(response.headers.entries()));
                
                // Log the full error response for debugging
                let fullErrorResponse;
                try {
                    fullErrorResponse = JSON.parse(errorText);
                    console.log('ðŸš— Detailed 401 error:', fullErrorResponse);
                } catch (e) {
                    console.log('ðŸš— Raw 401 error text:', errorText);
                }
                
                // Try to refresh token and retry
                console.log('ðŸš— Attempting token refresh...');
                if (typeof refreshToken === 'function') {
                    const refreshed = await refreshToken();
                    if (refreshed) {
                        console.log('ðŸš— Token refresh successful, please try again');
                        safeShowAlert('Session refreshed. Please try submitting again.', 'info', 3000);
                        return;
                    }
                }
                
                // If refresh failed or function not available
                console.error('ðŸš— Token refresh failed, redirecting to login');
                safeShowAlert('Session expired. Please login again.', 'warning', 3000);
                setTimeout(() => {
                    window.location.href = '/login/';
                }, 2000);
                return;
            }            let errorData;
            try {
                errorData = JSON.parse(errorText);
            } catch (parseError) {
                console.log('ðŸš— Could not parse error response as JSON:', parseError);
                throw new Error(`Server error: ${response.status} - ${errorText}`);
            }
            
            console.log('ðŸš— Error response data:', errorData);
            
            // Handle Django validation errors
            let errorMessage = 'Failed to request ride';
            if (errorData.message) {
                errorMessage = errorData.message;
            } else if (typeof errorData === 'object') {
                // Handle Django field validation errors
                const errorMessages = [];
                for (const [field, errors] of Object.entries(errorData)) {
                    if (Array.isArray(errors)) {
                        errorMessages.push(`${field}: ${errors.join(', ')}`);
                    } else {
                        errorMessages.push(`${field}: ${errors}`);
                    }
                }
                if (errorMessages.length > 0) {
                    errorMessage = errorMessages.join('; ');
                }
            }
            throw new Error(errorMessage);
        }
        
    } catch (error) {
        console.error('âŒ Error requesting ride:', error);
        safeShowAlert(error.message || 'Error requesting ride. Please try again.', 'danger');
    } finally {
        // Reset button state
        submitText.textContent = 'Request Ride';
        submitSpinner.classList.add('d-none');
        submitBtn.disabled = false;
    }
}

function validateRideForm() {
    console.log('Starting form validation...');
    
    const pickupLocation = document.getElementById('pickup_location').value.trim();
    const dropoffLocation = document.getElementById('dropoff_location').value.trim();
    const pickupLat = parseFloat(document.getElementById('pickup_latitude').value);
    const pickupLng = parseFloat(document.getElementById('pickup_longitude').value);
    const dropoffLat = parseFloat(document.getElementById('dropoff_latitude').value);
    const dropoffLng = parseFloat(document.getElementById('dropoff_longitude').value);
    const isScheduled = document.getElementById('scheduled').checked;
    const scheduledTime = document.getElementById('scheduled_pickup_time').value;
    
    console.log('Form validation data:', {
        pickupLocation,
        dropoffLocation,
        pickupLat,
        pickupLng,
        dropoffLat,
        dropoffLng,
        isScheduled,
        scheduledTime
    });
    
    if (!pickupLocation) {
        showAlert('Please enter a pickup location', 'warning');
        document.getElementById('pickup_location').focus();
        return false;
    }
    
    if (!dropoffLocation) {
        showAlert('Please enter a dropoff location', 'warning');
        document.getElementById('dropoff_location').focus();
        return false;
    }
    
    // Validate scheduled time if scheduled ride is selected
    if (isScheduled) {
        if (!scheduledTime) {
            showAlert('Please select a pickup time for scheduled ride', 'warning');
            document.getElementById('scheduled_pickup_time').focus();
            return false;
        }
        
        const scheduledDate = new Date(scheduledTime);
        const now = new Date();
        const minTime = new Date(now.getTime() + 30 * 60000); // 30 minutes from now
        
        if (scheduledDate <= minTime) {
            showAlert('Scheduled pickup time must be at least 30 minutes from now', 'warning');
            document.getElementById('scheduled_pickup_time').focus();
            return false;
        }
    }
    
    // If coordinates are missing, require user to search for locations
    if (!pickupLat || !pickupLng) {
        showAlert('Please search for pickup location to get coordinates', 'warning');
        document.getElementById('pickup_location').focus();
        return false;
    }
    
    if (!dropoffLat || !dropoffLng) {
        showAlert('Please search for dropoff location to get coordinates', 'warning');
        document.getElementById('dropoff_location').focus();
        return false;
    }
    
    if (pickupLocation.toLowerCase() === dropoffLocation.toLowerCase()) {
        showAlert('Pickup and dropoff locations cannot be the same', 'warning');
        return false;
    }
    
    console.log('Form validation passed successfully');
    return true;
}

// Helper function to format coordinates to 6 decimal places
function formatCoordinate(coord) {
    return parseFloat(parseFloat(coord).toFixed(6));
}

async function getCurrentLocation(type) {
    try {
        showAlert('Getting your current location...', 'info', 3000);
        
        // Try to get actual location first
        let location;
        try {
            location = await getUserLocation();
        } catch (error) {
            // Fallback to Lagos coordinates if geolocation fails
            location = { latitude: 6.5244, longitude: 3.3792 };
            console.log('Using fallback Lagos coordinates');
        }
        
        // Get real address from coordinates using reverse geocoding
        showAlert('Converting location to address...', 'info', 2000);
        
        try {
            const address = await reverseGeocode(location.latitude, location.longitude);
            
            if (type === 'pickup') {
                document.getElementById('pickup_location').value = address;
                document.getElementById('pickup_latitude').value = formatCoordinate(location.latitude);
                document.getElementById('pickup_longitude').value = formatCoordinate(location.longitude);
            } else if (type === 'dropoff') {
                document.getElementById('dropoff_location').value = address;
                document.getElementById('dropoff_latitude').value = formatCoordinate(location.latitude);
                document.getElementById('dropoff_longitude').value = formatCoordinate(location.longitude);
            }
            
            updateEstimates();
            updateMapWithRoute();
            showAlert('Location updated successfully', 'success', 2000);
            
        } catch (reverseGeocodingError) {
            console.error('Reverse geocoding failed:', reverseGeocodingError);
            
            // Fallback to a generic address format
            const fallbackAddress = `Current Location, Lagos, Nigeria`;
            
            if (type === 'pickup') {
                document.getElementById('pickup_location').value = fallbackAddress;
                document.getElementById('pickup_latitude').value = formatCoordinate(location.latitude);
                document.getElementById('pickup_longitude').value = formatCoordinate(location.longitude);
            } else if (type === 'dropoff') {
                document.getElementById('dropoff_location').value = fallbackAddress;
                document.getElementById('dropoff_latitude').value = formatCoordinate(location.latitude);
                document.getElementById('dropoff_longitude').value = formatCoordinate(location.longitude);
            }
            
            updateEstimates();
            updateMapWithRoute();
            showAlert('Location updated (address approximated)', 'warning', 3000);
        }
        
    } catch (error) {
        console.error('Error getting location:', error);
        showAlert('Unable to get your location. Please enter it manually.', 'warning');
    }
}

function updateEstimates() {
    const pickupLat = parseFloat(document.getElementById('pickup_latitude').value);
    const pickupLng = parseFloat(document.getElementById('pickup_longitude').value);
    const dropoffLat = parseFloat(document.getElementById('dropoff_latitude').value);
    const dropoffLng = parseFloat(document.getElementById('dropoff_longitude').value);
    
    if (pickupLat && pickupLng && dropoffLat && dropoffLng) {
        // Calculate estimates
        const distance = calculateDistance(pickupLat, pickupLng, dropoffLat, dropoffLng);
        const duration = Math.round(distance * 2.5); // Rough estimate: 2.5 minutes per km
        
        // Check if FARE_CONFIG is properly initialized
        if (typeof FARE_CONFIG === 'undefined' || !FARE_CONFIG.base_fare) {
            console.warn('FARE_CONFIG not ready, using default values');
            const baseFare = 100; // Default fallback
            const perKmRate = 50; // Default fallback
            const fare = baseFare + (distance * perKmRate);
            
            document.getElementById('estimated-distance').textContent = `${distance.toFixed(2)} km`;
            document.getElementById('estimated-duration').textContent = `${duration} min`;
            document.getElementById('estimated-fare').textContent = `â‚¦${fare.toFixed(2)}`;
        } else {
            const baseFare = FARE_CONFIG.base_fare; // Base fare from backend
            const perKmRate = FARE_CONFIG.per_km_rate; // Rate per km from backend
            const fare = baseFare + (distance * perKmRate);
            
            document.getElementById('estimated-distance').textContent = `${distance.toFixed(2)} km`;
            document.getElementById('estimated-duration').textContent = `${duration} min`;
            document.getElementById('estimated-fare').textContent = `${FARE_CONFIG.currency_symbol}${fare.toFixed(2)}`;
        }
        
        // Update map if available
        updateMapWithRoute();
    } else {
        clearEstimates();
    }
}

function clearEstimates() {
    document.getElementById('estimated-distance').textContent = '--';
    document.getElementById('estimated-duration').textContent = '--';
    document.getElementById('estimated-fare').textContent = '--';
}

function goToDashboard() {
    window.location.href = '/dashboard/';
}

// Handle ride type change (immediate vs scheduled)
function handleRideTypeChange() {
    const isScheduled = document.getElementById('scheduled').checked;
    const scheduledSection = document.getElementById('scheduled-time-section');
    const scheduledInput = document.getElementById('scheduled_pickup_time');
    
    if (isScheduled) {
        scheduledSection.classList.remove('d-none');
        scheduledInput.required = true;
    } else {
        scheduledSection.classList.add('d-none');
        scheduledInput.required = false;
        scheduledInput.value = '';
    }
}

// Enhanced location search function
async function searchLocation(type) {
    const locationInput = document.getElementById(`${type}_location`);
    const address = locationInput.value.trim();
    
    if (!address) {
        showAlert('Please enter an address to search', 'warning');
        return;
    }
    
    try {
        showAlert('Searching for location...', 'info', 3000);
        
        let coords;
        if (window.useGoogleMaps && typeof google !== 'undefined') {
            // Use Google Maps Geocoding for more accurate results
            coords = await geocodeAddressGoogle(address);
            
            // Update the input with the formatted address from Google
            if (coords.formatted_address) {
                locationInput.value = coords.formatted_address;
            }
        } else {
            // Use fallback geocoding
            coords = await geocodeAddress(address);
        }
        
        // Set the coordinates
        document.getElementById(`${type}_latitude`).value = formatCoordinate(coords.latitude);
        document.getElementById(`${type}_longitude`).value = formatCoordinate(coords.longitude);
        
        console.log(`${type} location coordinates set:`, {
            address: locationInput.value,
            latitude: coords.latitude,
            longitude: coords.longitude
        });
        
        updateEstimates();
        updateMapWithRoute();
        showAlert('Location coordinates found successfully', 'success', 2000);
        
    } catch (error) {
        console.error('Error searching location:', error);
        showAlert('Unable to find location. Please check the address or try selecting from suggestions.', 'warning', 4000);
    }
}

// Google Maps geocoding function
function geocodeAddressGoogle(address) {
    return new Promise((resolve, reject) => {
        if (!window.useGoogleMaps || typeof google === 'undefined') {
            reject(new Error('Google Maps not available'));
            return;
        }
        
        const geocoder = new google.maps.Geocoder();
        geocoder.geocode({
            address: address,
            componentRestrictions: { country: 'NG' },
            region: 'NG'
        }, (results, status) => {
            if (status === 'OK' && results[0]) {
                const location = results[0].geometry.location;
                const result = {
                    latitude: location.lat(),
                    longitude: location.lng(),
                    formatted_address: results[0].formatted_address
                };
                
                console.log('Google geocoding successful:', result);
                resolve(result);
            } else {
                console.log('Google geocoding failed:', status);
                
                // Provide specific error messages
                let errorMessage = 'Location not found';
                switch(status) {
                    case 'ZERO_RESULTS':
                        errorMessage = 'No results found for this address';
                        break;
                    case 'OVER_QUERY_LIMIT':
                        errorMessage = 'Too many requests. Please try again later';
                        break;
                    case 'REQUEST_DENIED':
                        errorMessage = 'Geocoding request denied';
                        break;
                    case 'INVALID_REQUEST':
                        errorMessage = 'Invalid address format';
                        break;
                }
                
                reject(new Error(errorMessage));
            }
        });
    });
}

// Geocode address using OpenStreetMap Nominatim API
function geocodeAddress(address) {
    return new Promise((resolve, reject) => {
        // First try to find exact matches in our Nigerian cities database
        const cityMatch = nigerianCities.find(city => 
            address.toLowerCase().includes(city.name.toLowerCase()) ||
            address.toLowerCase().includes(city.state.toLowerCase())
        );
        
        if (cityMatch) {
            console.log('Found city match:', cityMatch);
            resolve({
                latitude: cityMatch.lat,
                longitude: cityMatch.lng,
                display_name: `${cityMatch.name}, ${cityMatch.state}, Nigeria`
            });
            return;
        }

        // Fallback to Nominatim API for geocoding
        const encodedAddress = encodeURIComponent(address + ', Nigeria');
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodedAddress}&limit=1&countrycodes=ng`;
        
        fetch(url)
            .then(response => response.json())
            .then(data => {
                if (data && data.length > 0) {
                    const result = data[0];
                    resolve({
                        latitude: parseFloat(result.lat),
                        longitude: parseFloat(result.lon),
                        display_name: result.display_name
                    });
                } else {
                    // Final fallback to Lagos coordinates
                    console.log('No results found, using Lagos fallback');
                    resolve({
                        latitude: 6.5244,
                        longitude: 3.3792,
                        display_name: 'Lagos, Nigeria (fallback)'
                    });
                }
            })
            .catch(error => {
                console.error('Geocoding error:', error);
                // Fallback to Lagos coordinates
                resolve({
                    latitude: 6.5244,
                    longitude: 3.3792,
                    display_name: 'Lagos, Nigeria (fallback)'
                });
            });
    });
}

// Reverse geocode coordinates to get address
function reverseGeocode(latitude, longitude) {
    return new Promise((resolve, reject) => {
        // Try Google Maps reverse geocoding first if available
        if (typeof google !== 'undefined' && google.maps && google.maps.Geocoder) {
            const geocoder = new google.maps.Geocoder();
            const latlng = { lat: latitude, lng: longitude };
            
            geocoder.geocode({ location: latlng }, (results, status) => {
                if (status === 'OK' && results && results.length > 0) {
                    // Find the most specific address (usually the first result)
                    for (const result of results) {
                        // Prefer results with street addresses
                        if (result.types.includes('street_address') || 
                            result.types.includes('premise') ||
                            result.types.includes('subpremise')) {
                            resolve(result.formatted_address);
                            return;
                        }
                    }
                    // If no street address, use the first result
                    resolve(results[0].formatted_address);
                    return;
                }
                
                // Fallback to Nominatim if Google fails
                fallbackToNominatim();
            });
        } else {
            // Google Maps not available, use Nominatim
            fallbackToNominatim();
        }
        
        function fallbackToNominatim() {
            // Use Nominatim reverse geocoding API
            const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=18&addressdetails=1&countrycodes=ng`;
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data && data.display_name) {
                        // Clean up the address to make it more readable
                        let address = data.display_name;
                        
                        // If we have address components, build a cleaner address
                        if (data.address) {
                            const addr = data.address;
                            const parts = [];
                            
                            // Add street/road information
                            if (addr.road || addr.street) {
                                parts.push(addr.road || addr.street);
                            }
                            
                            // Add area/neighborhood
                            if (addr.suburb || addr.neighbourhood || addr.village) {
                                parts.push(addr.suburb || addr.neighbourhood || addr.village);
                            }
                            
                            // Add city/town
                            if (addr.city || addr.town || addr.village) {
                                parts.push(addr.city || addr.town || addr.village);
                            }
                            
                            // Add state
                            if (addr.state) {
                                parts.push(addr.state);
                            }
                            
                            // Add country
                            if (addr.country) {
                                parts.push(addr.country);
                            }
                            
                            if (parts.length > 0) {
                                address = parts.join(', ');
                            }
                        }
                        
                        resolve(address);
                    } else {
                        // Final fallback - check known cities with tighter threshold
                        checkNearbyCity();
                    }
                })
                .catch(error => {
                    console.error('Reverse geocoding error:', error);
                    // Final fallback
                    checkNearbyCity();
                });
        }
        
        function checkNearbyCity() {
            // Check if coordinates are close to any known Nigerian cities (with smaller threshold)
            const DISTANCE_THRESHOLD = 15; // Reduced to 15km for more accuracy
            let closestCity = null;
            let closestDistance = Infinity;
            
            for (const city of nigerianCities) {
                const distance = calculateDistanceKm(latitude, longitude, city.lat, city.lng);
                if (distance <= DISTANCE_THRESHOLD && distance < closestDistance) {
                    closestDistance = distance;
                    closestCity = city;
                }
            }
            
            if (closestCity) {
                console.log(`Location is within ${closestDistance.toFixed(1)}km of ${closestCity.name}, ${closestCity.state}`);
                resolve(`Near ${closestCity.name}, ${closestCity.state}, Nigeria`);
            } else {
                // Ultimate fallback - use coordinates with "Nigeria" added
                resolve(`Location at ${latitude.toFixed(4)}, ${longitude.toFixed(4)}, Nigeria`);
            }
        }
    });
}

// Helper function to calculate distance between coordinates
function calculateDistanceKm(lat1, lon1, lat2, lon2) {
    const R = 6371; // Radius of the Earth in kilometers
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

// Location suggestions functionality
function setupLocationSuggestions(type) {
    const input = document.getElementById(`${type}_location`);
    const suggestionsDiv = document.getElementById(`${type}-suggestions`);
    
    if (!input || !suggestionsDiv) return;
    
    // Debounced input handler
    let timeout;
    input.addEventListener('input', function() {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            const query = this.value.trim();
            if (query.length >= 2) {
                showSuggestions(type, query);
            } else {
                hideSuggestions(type);
            }
        }, 300);
    });
    
    // Keyboard navigation
    input.addEventListener('keydown', function(e) {
        handleSuggestionKeydown(e, type);
    });
}

function showSuggestions(type, query) {
    const suggestionsDiv = document.getElementById(`${type}-suggestions`);
    
    // Filter Nigerian cities based on query
    const matches = nigerianCities.filter(city => 
        city.name.toLowerCase().includes(query.toLowerCase()) ||
        city.state.toLowerCase().includes(query.toLowerCase())
    ).slice(0, 5); // Limit to 5 suggestions
    
    if (matches.length === 0) {
        hideSuggestions(type);
        return;
    }
    
    const suggestionsHTML = matches.map(city => `
        <div class="suggestion-item" onclick="selectSuggestion('${type}', '${city.name}, ${city.state}', ${city.lat}, ${city.lng})">
            <div class="suggestion-main">${city.name}</div>
            <div class="suggestion-sub">${city.state}, Nigeria</div>
        </div>
    `).join('');
    
    suggestionsDiv.innerHTML = suggestionsHTML;
    suggestionsDiv.classList.remove('d-none');
    suggestionsDiv._activeIndex = -1;
}

function hideSuggestions(type) {
    const suggestionsDiv = document.getElementById(`${type}-suggestions`);
    if (suggestionsDiv) {
        suggestionsDiv.classList.add('d-none');
        suggestionsDiv._activeIndex = -1;
    }
}

function selectSuggestion(type, address, lat, lng) {
    document.getElementById(`${type}_location`).value = address;
    document.getElementById(`${type}_latitude`).value = formatCoordinate(lat);
    document.getElementById(`${type}_longitude`).value = formatCoordinate(lng);
    
    hideSuggestions(type);
    updateEstimates();
    updateMapWithRoute();
}

function handleSuggestionKeydown(e, type) {
    const suggestionsDiv = document.getElementById(`${type}-suggestions`);
    if (suggestionsDiv.classList.contains('d-none')) return;
    
    const items = suggestionsDiv.querySelectorAll('.suggestion-item');
    if (items.length === 0) return;
    
    switch(e.key) {
        case 'ArrowDown':
            e.preventDefault();
            suggestionsDiv._activeIndex = Math.min(suggestionsDiv._activeIndex + 1, items.length - 1);
            updateActiveItem(suggestionsDiv);
            break;
        case 'ArrowUp':
            e.preventDefault();
            suggestionsDiv._activeIndex = Math.max(suggestionsDiv._activeIndex - 1, -1);
            updateActiveItem(suggestionsDiv);
            break;
        case 'Enter':
            e.preventDefault();
            if (suggestionsDiv._activeIndex >= 0) {
                items[suggestionsDiv._activeIndex].click();
            }
            break;
        case 'Escape':
            hideSuggestions(type);
            break;
    }
}

function updateActiveItem(suggestions) {
    const items = suggestions.querySelectorAll('.suggestion-item');
    
    // Remove active class from all items
    items.forEach(item => item.classList.remove('active'));
    
    // Add active class to current item
    if (suggestions._activeIndex >= 0 && suggestions._activeIndex < items.length) {
        items[suggestions._activeIndex].classList.add('active');
        items[suggestions._activeIndex].scrollIntoView({ block: 'nearest' });
    }
}

// Global flag to determine which map system to use
window.useGoogleMaps = false;

function initMapGoogle() {
    if (!window.useGoogleMaps || typeof google === 'undefined') {
        console.log('Google Maps not available, using fallback map');
        initFallbackMap();
        return;
    }
    
    try {
        // Initialize Google Maps
        map = new google.maps.Map(document.getElementById('map'), {
            center: { lat: 6.5244, lng: 3.3792 },
            zoom: 12,
            mapTypeControl: false,
            streetViewControl: false,
            fullscreenControl: false,
            styles: [
                {
                    featureType: 'poi',
                    elementType: 'labels',
                    stylers: [{ visibility: 'off' }]
                }
            ]
        });

        // Initialize directions service and renderer
        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
            draggable: false,
            suppressMarkers: false,
            polylineOptions: {
                strokeColor: '#007bff',
                strokeWeight: 4,
                strokeOpacity: 0.8
            }
        });
        directionsRenderer.setMap(map);

        // Initialize Places Autocomplete for location inputs
        initializeAutocomplete();

        // Hide placeholder when map is ready
        document.getElementById('map-placeholder').style.display = 'none';
        document.getElementById('map').style.display = 'block';
        
        console.log('Google Maps initialized successfully');
        
    } catch (error) {
        console.error('Error initializing Google Maps:', error);
        window.useGoogleMaps = false;
        initFallbackMap();
    }
}

function initFallbackMapSimple() {
    try {
        // Initialize basic Leaflet map without routing
        map = L.map('map').setView([6.5244, 3.3792], 12);
        
        // Add tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        
        // Initialize global variables for Leaflet
        window.leafletControl = null;
        window.leafletMarkers = [];
        
        // Hide placeholder when map is ready
        document.getElementById('map-placeholder').style.display = 'none';
        document.getElementById('map').style.display = 'block';
        
        console.log('Basic Leaflet map initialized successfully (without routing)');
        
    } catch (error) {
        console.error('Error initializing basic fallback map:', error);
        showMapError();
    }
}

function showMapError() {
    const placeholder = document.getElementById('map-placeholder');
    if (placeholder) {
        placeholder.innerHTML = `
            <div class="text-center p-4">
                <i class="fas fa-exclamation-triangle display-4 mb-3 text-warning"></i>
                <p class="text-muted">Map temporarily unavailable</p>
                <small class="text-muted">You can still request rides - route information will be calculated</small>
                <button class="btn btn-sm btn-outline-primary mt-2" onclick="retryMapInit()">
                    <i class="fas fa-redo me-1"></i>Retry
                </button>
            </div>
        `;
        placeholder.style.display = 'flex';
        placeholder.style.alignItems = 'center';
        placeholder.style.justifyContent = 'center';
    }
}

function retryMapInit() {
    console.log('Retrying map initialization...');
    window.leafletInitAttempts = 0;
    document.getElementById('map-placeholder').innerHTML = `
        <div class="text-center">
            <i class="fas fa-spinner fa-spin display-4 mb-3 text-primary"></i>
            <p class="text-muted">Loading map...</p>
        </div>
    `;
    checkLeafletAndInit();
}

function initFallbackMap() {
    // Wait for Leaflet and routing to be available
    if (typeof L === 'undefined') {
        console.log('Waiting for Leaflet to load...');
        setTimeout(initFallbackMap, 100);
        return;
    }
    
    if (typeof L.Routing === 'undefined') {
        console.log('Waiting for Leaflet Routing Machine to load...');
        setTimeout(initFallbackMap, 100);
        return;
    }
    
    try {
        // Initialize Leaflet map
        map = L.map('map').setView([6.5244, 3.3792], 12);
        
        // Add tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        
        // Initialize global variables for Leaflet
        window.leafletControl = null;
        window.leafletMarkers = [];
        
        // Hide placeholder when map is ready
        document.getElementById('map-placeholder').style.display = 'none';
        document.getElementById('map').style.display = 'block';
        
        console.log('Leaflet fallback map initialized successfully');
        
    } catch (error) {
        console.error('Error initializing fallback map:', error);
        // Show placeholder with error message
        const placeholder = document.getElementById('map-placeholder');
        placeholder.innerHTML = `
            <div class="text-center">
                <i class="fas fa-map-marked-alt display-4 mb-3 text-muted"></i>
                <p class="text-muted">Map temporarily unavailable</p>
                <small class="text-muted">Route information will still be calculated</small>
            </div>
        `;
    }
}

function initFallbackMapSimple() {
    try {
        // Initialize basic Leaflet map without routing
        map = L.map('map').setView([6.5244, 3.3792], 12);
        
        // Add tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        
        // Initialize global variables for Leaflet
        window.leafletControl = null;
        window.leafletMarkers = [];
        
        // Hide placeholder when map is ready
        document.getElementById('map-placeholder').style.display = 'none';
        document.getElementById('map').style.display = 'block';
        
        console.log('Basic Leaflet map initialized successfully (without routing)');
        
    } catch (error) {
        console.error('Error initializing basic fallback map:', error);
        showMapError();
    }
}

function showMapError() {
    const placeholder = document.getElementById('map-placeholder');
    if (placeholder) {
        placeholder.innerHTML = `
            <div class="text-center p-4">
                <i class="fas fa-exclamation-triangle display-4 mb-3 text-warning"></i>
                <p class="text-muted">Map temporarily unavailable</p>
                <small class="text-muted">You can still request rides - route information will be calculated</small>
                <button class="btn btn-sm btn-outline-primary mt-2" onclick="retryMapInit()">
                    <i class="fas fa-redo me-1"></i>Retry
                </button>
            </div>
        `;
        placeholder.style.display = 'flex';
        placeholder.style.alignItems = 'center';
        placeholder.style.justifyContent = 'center';
    }
}

function retryMapInit() {
    console.log('Retrying map initialization...');
    window.leafletInitAttempts = 0;
    document.getElementById('map-placeholder').innerHTML = `
        <div class="text-center">
            <i class="fas fa-spinner fa-spin display-4 mb-3 text-primary"></i>
            <p class="text-muted">Loading map...</p>
        </div>
    `;
    checkLeafletAndInit();
}

// ...existing code...

function updateMap() {
    if (!map) {
        console.log('Map not initialized, trying to initialize...');
        if (window.useGoogleMaps && typeof google !== 'undefined') {
            initMap();
        } else {
            initFallbackMap();
        }
        // Wait for map to initialize then update
        setTimeout(() => {
            if (map) {
                updateMap();
            }
        }, 500);
        return;
    }
    
    const pickupLat = parseFloat(document.getElementById('pickup_latitude').value);
    const pickupLng = parseFloat(document.getElementById('pickup_longitude').value);
    const dropoffLat = parseFloat(document.getElementById('dropoff_latitude').value);
    const dropoffLng = parseFloat(document.getElementById('dropoff_longitude').value);
    
    console.log('Updating map with coordinates:', { pickupLat, pickupLng, dropoffLat, dropoffLng });
    
    if (window.useGoogleMaps && typeof google !== 'undefined') {
        updateGoogleMap(pickupLat, pickupLng, dropoffLat, dropoffLng);
    } else {
        updateLeafletMap(pickupLat, pickupLng, dropoffLat, dropoffLng);
    }
}

function updateGoogleMap(pickupLat, pickupLng, dropoffLat, dropoffLng) {
    // Clear existing markers
    if (pickupMarker) {
        pickupMarker.setMap(null);
        pickupMarker = null;
    }
    if (dropoffMarker) {
        dropoffMarker.setMap(null);
        dropoffMarker = null;
    }
    
    // Clear existing route
    if (directionsRenderer) {
        directionsRenderer.setDirections({ routes: [] });
    }
    
    const bounds = new google.maps.LatLngBounds();
    let hasValidCoordinates = false;
    
    // Add pickup marker
    if (pickupLat && pickupLng && !isNaN(pickupLat) && !isNaN(pickupLng)) {
        const pickupPos = { lat: pickupLat, lng: pickupLng };
        pickupMarker = new google.maps.Marker({
            position: pickupPos,
            map: map,
            title: 'Pickup Location',
            icon: {
                url: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png',
                scaledSize: new google.maps.Size(32, 32)
            }
        });
        
        const pickupInfoWindow = new google.maps.InfoWindow({
            content: '<strong>Pickup Location</strong><br>' + document.getElementById('pickup_location').value
        });
        
        pickupMarker.addListener('click', () => {
            pickupInfoWindow.open(map, pickupMarker);
        });
        
        bounds.extend(pickupPos);
        hasValidCoordinates = true;
        console.log('Added pickup marker at:', pickupLat, pickupLng);
    }
    
    // Add dropoff marker
    if (dropoffLat && dropoffLng && !isNaN(dropoffLat) && !isNaN(dropoffLng)) {
        const dropoffPos = { lat: dropoffLat, lng: dropoffLng };
        dropoffMarker = new google.maps.Marker({
            position: dropoffPos,
            map: map,
            title: 'Dropoff Location',
            icon: {
                url: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png',
                scaledSize: new google.maps.Size(32, 32)
            }
        });
        
        const dropoffInfoWindow = new google.maps.InfoWindow({
            content: '<strong>Dropoff Location</strong><br>' + document.getElementById('dropoff_location').value
        });
        
        dropoffMarker.addListener('click', () => {
            dropoffInfoWindow.open(map, dropoffMarker);
        });
        
        bounds.extend(dropoffPos);
        hasValidCoordinates = true;
        console.log('Added dropoff marker at:', dropoffLat, dropoffLng);
    }
    
    // Draw route if both points exist
    if (pickupMarker && dropoffMarker) {
        const request = {
            origin: pickupMarker.getPosition(),
            destination: dropoffMarker.getPosition(),
            travelMode: google.maps.TravelMode.DRIVING,
            unitSystem: google.maps.UnitSystem.METRIC,
            avoidHighways: false,
            avoidTolls: false
        };
        
        directionsService.route(request, (result, status) => {
            if (status === 'OK') {
                directionsRenderer.setDirections(result);
                console.log('Route displayed successfully');
                
                // Calculate and display route info
                const route = result.routes[0];
                const leg = route.legs[0];
                const distance = leg.distance.text;
                const duration = leg.duration.text;
                
                console.log(`Route: ${distance}, ${duration}`);
                
                // Update fare calculation with route distance
                updateFareEstimate(leg.distance.value, leg.duration.value);
            } else {
                console.error('Directions request failed due to ' + status);
                // Fall back to fitting bounds if route fails
                if (hasValidCoordinates) {
                    map.fitBounds(bounds, { padding: 50 });
                }
                // Use straight-line distance for fare calculation
                if (pickupLat && pickupLng && dropoffLat && dropoffLng) {
                    const distance = calculateDistance(pickupLat, pickupLng, dropoffLat, dropoffLng);
                    updateFareEstimateFromDistance(distance);
                }
            }
        });
    } else if (hasValidCoordinates) {
        // Center on available markers
        map.fitBounds(bounds, { padding: 50 });
        console.log('Centered on available markers');
    }
}

function updateLeafletMap(pickupLat, pickupLng, dropoffLat, dropoffLng) {
    // Check if Leaflet is available
    if (typeof L === 'undefined') {
        console.log('Leaflet not yet available, waiting...');
        setTimeout(() => updateLeafletMap(pickupLat, pickupLng, dropoffLat, dropoffLng), 100);
        return;
    }
    
    // Clear existing markers and routing control
    if (window.leafletMarkers && window.leafletMarkers.length > 0) {
        window.leafletMarkers.forEach(marker => {
            map.removeLayer(marker);
        });
        window.leafletMarkers = [];
    } else if (!window.leafletMarkers) {
        window.leafletMarkers = [];
    }
    
    if (window.leafletControl) {
        map.removeControl(window.leafletControl);
        window.leafletControl = null;
    }
    
    if (window.leafletRouteLine) {
        map.removeLayer(window.leafletRouteLine);
        window.leafletRouteLine = null;
    }
    
    const validPickup = pickupLat && pickupLng && !isNaN(pickupLat) && !isNaN(pickupLng);
    const validDropoff = dropoffLat && dropoffLng && !isNaN(dropoffLat) && !isNaN(dropoffLng);
    
    // Add pickup marker
    if (validPickup) {
        const pickupMarker = L.marker([pickupLat, pickupLng], {
            icon: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        }).addTo(map);
        
        pickupMarker.bindPopup('<strong>Pickup Location</strong><br>' + document.getElementById('pickup_location').value);
        
        // Ensure markers array exists before pushing
        if (!window.leafletMarkers) {
            window.leafletMarkers = [];
        }
        window.leafletMarkers.push(pickupMarker);
        console.log('Added pickup marker at:', pickupLat, pickupLng);
    }
    
    // Add dropoff marker
    if (validDropoff) {
        const dropoffMarker = L.marker([dropoffLat, dropoffLng], {
            icon: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        }).addTo(map);
        
        dropoffMarker.bindPopup('<strong>Dropoff Location</strong><br>' + document.getElementById('dropoff_location').value);
        
        // Ensure markers array exists before pushing
        if (!window.leafletMarkers) {
            window.leafletMarkers = [];
        }
        window.leafletMarkers.push(dropoffMarker);
        console.log('Added dropoff marker at:', dropoffLat, dropoffLng);
    }
    
    // Create route if both points exist and routing is available
    if (validPickup && validDropoff && typeof L.Routing !== 'undefined') {
        try {
            window.leafletControl = L.Routing.control({
                waypoints: [
                    L.latLng(pickupLat, pickupLng),
                    L.latLng(dropoffLat, dropoffLng)
                ],
                routeWhileDragging: false,
                addWaypoints: false,
                createMarker: function() { return null; }, // Don't create default markers
                lineOptions: {
                    styles: [{ color: '#007bff', weight: 4, opacity: 0.7 }]
                }
            }).on('routesfound', function(e) {
                const routes = e.routes;
                const summary = routes[0].summary;
                
                // Distance in meters, duration in seconds
                const distanceKm = summary.totalDistance / 1000;
                const durationMin = Math.round(summary.totalTime / 60);
                
                console.log(`Leaflet route found: ${distanceKm.toFixed(1)} km, ${durationMin} min`);
                
                // Update fare estimate
                updateFareEstimate(summary.totalDistance, summary.totalTime);
                
            }).addTo(map);
            
            console.log('Leaflet routing control added successfully');
            
        } catch (error) {
            console.error('Error creating Leaflet route:', error);
            // Fall back to simple line if routing fails
            addSimpleRouteLine(pickupLat, pickupLng, dropoffLat, dropoffLng);
        }
    } else if (validPickup && validDropoff) {
        // Routing not available, use simple line
        console.log('Routing library not available, using simple line');
        addSimpleRouteLine(pickupLat, pickupLng, dropoffLat, dropoffLng);
    } else if (window.leafletMarkers && window.leafletMarkers.length > 0) {
        // Fit map to show available markers
        if (window.leafletMarkers.length === 1) {
            map.setView(window.leafletMarkers[0].getLatLng(), 15);
        } else {
            const group = new L.featureGroup(window.leafletMarkers);
            map.fitBounds(group.getBounds().pad(0.1));
        }
        console.log('Centered map on available markers');
    }
}

function addSimpleRouteLine(pickupLat, pickupLng, dropoffLat, dropoffLng) {
    // Add simple straight line route
    const routeLine = L.polyline([[pickupLat, pickupLng], [dropoffLat, dropoffLng]], {
        color: '#007bff',
        weight: 4,
        opacity: 0.7,
        dashArray: '10, 5' // Dashed line to indicate it's not a real route
    }).addTo(map);
    
    // Store reference for cleanup
    window.leafletRouteLine = routeLine;
    
    // Fit map to show both markers with padding
    if (window.leafletMarkers && window.leafletMarkers.length > 0) {
        const group = new L.featureGroup(window.leafletMarkers);
        map.fitBounds(group.getBounds().pad(0.1));
    }
    
    // Calculate distance and update fare
    const distance = calculateDistance(pickupLat, pickupLng, dropoffLat, dropoffLng);
    updateFareEstimateFromDistance(distance);
    
    console.log('Added simple route line (no real routing available)');
}

// Helper function to resolve address to coordinates using Google Geocoding API or fallback
function geocodeAddress(address) {
    return new Promise((resolve, reject) => {
        if (!address) {
            return reject(new Error('Address is required for geocoding'));
        }
        
        // First, try to use the Google Geocoding API
        if (window.useGoogleMaps && typeof google !== 'undefined') {
            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({
                address: address,
                componentRestrictions: { country: 'NG' },
                region: 'NG'
            }, (results, status) => {
                if (status === 'OK' && results[0]) {
                    const location = results[0].geometry.location;
                    resolve({
                        latitude: location.lat(),
                        longitude: location.lng(),
                        formatted_address: results[0].formatted_address
                    });
                } else {
                    console.log('Google geocoding failed, using fallback');
                    resolveFallbackLocation(address, resolve);
                }
            });
        } else {
            // Use fallback geocoding
            resolveFallbackLocation(address, resolve);
        }
    });
}

function resolveFallbackLocation(address, resolve) {
    // Fallback to Nigerian locations database
    const fallbackLocations = {
        'lagos': { latitude: 6.5244, longitude: 3.3792 },
        'ikeja': { latitude: 6.6018, longitude: 3.3515 },
        'victoria island': { latitude: 6.4281, longitude: 3.4219 },
        'ikoyi': { latitude: 6.4474, longitude: 3.4323 },
        'surulere': { latitude: 6.4969, longitude: 3.3654 },
        'yaba': { latitude: 6.5158, longitude: 3.3707 },
        'lekki': { latitude: 6.4698, longitude: 3.5852 },
        'ajah': { latitude: 6.4698, longitude: 3.6043 },
        'maryland': { latitude: 6.5568, longitude: 3.3724 },
        'gbagada': { latitude: 6.5568, longitude: 3.3835 },
        'abuja': { latitude: 9.0765, longitude: 7.3986 },
        'kano': { latitude: 12.0022, longitude: 8.5920 },
        'port harcourt': { latitude: 4.8156, longitude: 7.0498 },
        'ibadan': { latitude: 7.3775, longitude: 3.9470 }
    };
    
    const searchLower = address.toLowerCase();
    for (const [key, coords] of Object.entries(fallbackLocations)) {
        if (searchLower.includes(key)) {
            resolve({
                latitude: coords.latitude + (Math.random() - 0.5) * 0.001,
                longitude: coords.longitude + (Math.random() - 0.5) * 0.001,
                formatted_address: address
            });
            return;
        }
    }
    
    // Default to Lagos if nothing matches
    resolve({
        latitude: 6.5244 + (Math.random() - 0.5) * 0.05,
        longitude: 3.3792 + (Math.random() - 0.5) * 0.05,
        formatted_address: address
    });
}

// Helper function to calculate distance between two coordinates (Haversine formula)
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371; // Radius of the Earth in kilometers
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLng / 2) * Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c; // Distance in kilometers
}

// Utility functions
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func.apply(this, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function formatCoordinate(coord) {
    return parseFloat(coord).toFixed(6);
}

function showAlert(message, type = 'success', duration = 3000) {
    // Create alert element
    const alert = document.createElement('div');
    alert.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
    alert.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
    alert.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    document.body.appendChild(alert);
    
    // Auto remove after duration
    if (duration > 0) {
        setTimeout(() => {
            if (alert.parentNode) {
                alert.remove();
            }
        }, duration);
    }
}

function formatCoordinate(coord) {
    return parseFloat(coord).toFixed(6);
}

function showAlert(message, type = 'success', duration = 3000) {
    // Create alert element
    const alert = document.createElement('div');
    alert.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
    alert.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
    alert.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    document.body.appendChild(alert);
    
    // Auto remove after duration
    if (duration > 0) {
        setTimeout(() => {
            if (alert.parentNode) {
                alert.remove();
            }
        }, duration);
    }
}

// Nigerian locations database for suggestions
const nigerianLocations = [
    // Lagos State
    { name: 'Ikeja', state: 'Lagos', fullName: 'Ikeja, Lagos State', coords: { latitude: 6.6018, longitude: 3.3515 }},
    { name: 'Victoria Island', state: 'Lagos', fullName: 'Victoria Island, Lagos State', coords: { latitude: 6.4281, longitude: 3.4219 }},
    { name: 'Ikoyi', state: 'Lagos', fullName: 'Ikoyi, Lagos State', coords: { latitude: 6.4474, longitude: 3.4323 }},
    { name: 'Surulere', state: 'Lagos', fullName: 'Surulere, Lagos State', coords: { latitude: 6.4969, longitude: 3.3654 }},
    { name: 'Yaba', state: 'Lagos', fullName: 'Yaba, Lagos State', coords: { latitude: 6.5158, longitude: 3.3707 }},
    { name: 'Lekki', state: 'Lagos', fullName: 'Lekki, Lagos State', coords: { latitude: 6.4698, longitude: 3.5852 }},
    { name: 'Ajah', state: 'Lagos', fullName: 'Ajah, Lagos State', coords: { latitude: 6.4698, longitude: 3.6043 }},
    { name: 'Maryland', state: 'Lagos', fullName: 'Maryland, Lagos State', coords: { latitude: 6.5568, longitude: 3.3724 }},
    { name: 'Gbagada', state: 'Lagos', fullName: 'Gbagada, Lagos State', coords: { latitude: 6.5568, longitude: 3.3835 }},
    { name: 'Magodo', state: 'Lagos', fullName: 'Magodo, Lagos State', coords: { latitude: 6.6017, longitude: 3.3799 }},
    { name: 'Oregun', state: 'Lagos', fullName: 'Oregun, Lagos State', coords: { latitude: 6.5568, longitude: 3.3724 }},
    { name: 'Apapa', state: 'Lagos', fullName: 'Apapa, Lagos State', coords: { latitude: 6.4474, longitude: 3.3594 }},
    { name: 'Lagos Island', state: 'Lagos', fullName: 'Lagos Island, Lagos State', coords: { latitude: 6.4541, longitude: 3.3947 }},
    { name: 'Mushin', state: 'Lagos', fullName: 'Mushin, Lagos State', coords: { latitude: 6.5244, longitude: 3.3452 }},
    { name: 'Oshodi', state: 'Lagos', fullName: 'Oshodi, Lagos State', coords: { latitude: 6.5492, longitude: 3.3348 }},
    { name: 'Alaba', state: 'Lagos', fullName: 'Alaba, Lagos State', coords: { latitude: 6.4641, longitude: 3.1794 }},
    { name: 'Isolo', state: 'Lagos', fullName: 'Isolo, Lagos State', coords: { latitude: 6.5244, longitude: 3.3267 }},
    { name: 'Ketu', state: 'Lagos', fullName: 'Ketu, Lagos State', coords: { latitude: 6.6018, longitude: 3.3903 }},
    { name: 'Mile 12', state: 'Lagos', fullName: 'Mile 12, Lagos State', coords: { latitude: 6.6267, longitude: 3.3903 }},
    { name: 'Ojota', state: 'Lagos', fullName: 'Ojota, Lagos State', coords: { latitude: 6.5568, longitude: 3.3903 }},
    
    // FCT Abuja
    { name: 'Wuse', state: 'FCT', fullName: 'Wuse, Abuja FCT', coords: { latitude: 9.0579, longitude: 7.4951 }},
    { name: 'Garki', state: 'FCT', fullName: 'Garki, Abuja FCT', coords: { latitude: 9.0579, longitude: 7.4951 }},
    { name: 'Maitama', state: 'FCT', fullName: 'Maitama, Abuja FCT', coords: { latitude: 9.0579, longitude: 7.4951 }},
    { name: 'Gwarinpa', state: 'FCT', fullName: 'Gwarinpa, Abuja FCT', coords: { latitude: 9.1579, longitude: 7.4951 }},
    { name: 'Kubwa', state: 'FCT', fullName: 'Kubwa, Abuja FCT', coords: { latitude: 9.1579, longitude: 7.3451 }},
    { name: 'Nyanya', state: 'FCT', fullName: 'Nyanya, Abuja FCT', coords: { latitude: 8.9579, longitude: 7.4951 }},
    
    // Other major cities
    { name: 'Kano', state: 'Kano', fullName: 'Kano, Kano State', coords: { latitude: 12.0022, longitude: 8.5920 }},
    { name: 'Port Harcourt', state: 'Rivers', fullName: 'Port Harcourt, Rivers State', coords: { latitude: 4.8156, longitude: 7.0498 }},
    { name: 'Ibadan', state: 'Oyo', fullName: 'Ibadan, Oyo State', coords: { latitude: 7.3775, longitude: 3.9470 }},
    { name: 'Benin City', state: 'Edo', fullName: 'Benin City, Edo State', coords: { latitude: 6.3350, longitude: 5.6037 }},
    { name: 'Enugu', state: 'Enugu', fullName: 'Enugu, Enugu State', coords: { latitude: 6.5244, longitude: 7.5086 }},
    { name: 'Kaduna', state: 'Kaduna', fullName: 'Kaduna, Kaduna State', coords: { latitude: 10.5222, longitude: 7.4383 }},
    { name: 'Jos', state: 'Plateau', fullName: 'Jos, Plateau State', coords: { latitude: 9.8965, longitude: 8.8583 }},
    { name: 'Warri', state: 'Delta', fullName: 'Warri, Delta State', coords: { latitude: 5.5160, longitude: 5.7500 }},
    { name: 'Calabar', state: 'Cross River', fullName: 'Calabar, Cross River State', coords: { latitude: 4.9517, longitude: 8.3220 }},
    { name: 'Uyo', state: 'Akwa Ibom', fullName: 'Uyo, Akwa Ibom State', coords: { latitude: 5.0104, longitude: 7.8584 }},
    { name: 'Osun', state: 'Osun', fullName: 'Osogbo, Osun State', coords: { latitude: 7.7699, longitude: 4.5569 }},
    { name: 'Abeokuta', state: 'Ogun', fullName: 'Abeokuta, Ogun State', coords: { latitude: 7.1607, longitude: 3.3500 }},
    { name: 'Ilorin', state: 'Kwara', fullName: 'Ilorin, Kwara State', coords: { latitude: 8.4916, longitude: 4.5481 }},
    { name: 'Maiduguri', state: 'Borno', fullName: 'Maiduguri, Borno State', coords: { latitude: 11.8451, longitude: 13.1570 }},
    { name: 'Yola', state: 'Adamawa', fullName: 'Yola, Adamawa State', coords: { latitude: 9.2035, longitude: 12.4852 }},
    { name: 'Sokoto', state: 'Sokoto', fullName: 'Sokoto, Sokoto State', coords: { latitude: 13.0645, longitude: 5.2483 }},
    { name: 'Zaria', state: 'Kaduna', fullName: 'Zaria, Kaduna State', coords: { latitude: 11.1111, longitude: 7.7222 }},
    { name: 'Aba', state: 'Abia', fullName: 'Aba, Abia State', coords: { latitude: 5.1050, longitude: 7.3667 }},
    { name: 'Onitsha', state: 'Anambra', fullName: 'Onitsha, Anambra State', coords: { latitude: 6.1500, longitude: 6.8000 }},
    { name: 'Owerri', state: 'Imo', fullName: 'Owerri, Imo State', coords: { latitude: 5.4833, longitude: 7.0333 }}
];

// Setup location suggestions
function setupLocationSuggestions(type) {
    const input = document.getElementById(`${type}_location`);
    const suggestions = document.getElementById(`${type}-suggestions`);
    
    input.addEventListener('input', debounce(function() {
        const query = input.value.trim();
        if (query.length >= 2) {
            showLocationSuggestions(type, query);
        } else {
            hideSuggestions(type);
        }
    }, 300));
    
    input.addEventListener('focus', function() {
        const query = input.value.trim();
        if (query.length >= 2) {
            showLocationSuggestions(type, query);
        }
    });
    
    input.addEventListener('keydown', function(e) {
        handleSuggestionNavigation(e, type);
    });
}

function showLocationSuggestions(type, query) {
    const suggestions = document.getElementById(`${type}-suggestions`);
    const matches = findLocationMatches(query);
    
    if (matches.length === 0) {
        hideSuggestions(type);
        return;
    }
    
    let html = '';
    matches.slice(0, 8).forEach((location, index) => {
        html += `
            <div class="suggestion-item" data-index="${index}" onclick="selectSuggestion('${type}', ${index})">
                <div class="suggestion-main">${location.name}</div>
                <div class="suggestion-sub">${location.fullName}</div>
            </div>
        `;
    });
    
    suggestions.innerHTML = html;
    suggestions.classList.remove('d-none');
    
    // Store current matches for keyboard navigation
    suggestions._currentMatches = matches.slice(0, 8);
    suggestions._activeIndex = -1;
}

function hideSuggestions(type) {
    const suggestions = document.getElementById(`${type}-suggestions`);
    suggestions.classList.add('d-none');
    suggestions._activeIndex = -1;
}

function findLocationMatches(query) {
    const queryLower = query.toLowerCase();
    const matches = [];
    
    // Find exact matches first
    nigerianLocations.forEach(location => {
        if (location.name.toLowerCase().startsWith(queryLower) || 
            location.fullName.toLowerCase().includes(queryLower)) {
            matches.push(location);
        }
    });
    
    // If we need more matches, add partial matches
    if (matches.length < 8) {
        nigerianLocations.forEach(location => {
            if (!matches.includes(location) && 
                (location.name.toLowerCase().includes(queryLower) || 
                 location.state.toLowerCase().includes(queryLower))) {
                matches.push(location);
            }
        });
    }
    
    return matches;
}

function selectSuggestion(type, index) {
    const suggestions = document.getElementById(`${type}-suggestions`);
    const matches = suggestions._currentMatches;
    
    if (matches && matches[index]) {
        const location = matches[index];
        
        // Set the input value
        document.getElementById(`${type}_location`).value = location.fullName;
        
        // Set coordinates
        document.getElementById(`${type}_latitude`).value = formatCoordinate(location.coords.latitude);
        document.getElementById(`${type}_longitude`).value = formatCoordinate(location.coords.longitude);
        
        // Hide suggestions
        hideSuggestions(type);
        
        // Update estimates and map
        updateEstimates();
        updateMapWithRoute();
        
        showAlert(`Selected: ${location.name}`, 'success', 2000);
    }
}

function handleSuggestionNavigation(e, type) {
    const suggestions = document.getElementById(`${type}-suggestions`);
    
    if (suggestions.classList.contains('d-none')) return;
    
    const items = suggestions.querySelectorAll('.suggestion-item');
    if (items.length === 0) return;
    
    switch(e.key) {
        case 'ArrowDown':
            e.preventDefault();
            suggestions._activeIndex = Math.min(suggestions._activeIndex + 1, items.length - 1);
            updateActiveSuggestion(type);
            break;
            
        case 'ArrowUp':
            e.preventDefault();
            suggestions._activeIndex = Math.max(suggestions._activeIndex - 1, -1);
            updateActiveSuggestion(type);
            break;
            
        case 'Enter':
            e.preventDefault();
            if (suggestions._activeIndex >= 0) {
                selectSuggestion(type, suggestions._activeIndex);
            }
            break;
            
        case 'Escape':
            hideSuggestions(type);
            break;
    }
}

function updateActiveSuggestion(type) {
    const suggestions = document.getElementById(`${type}-suggestions`);
    const items = suggestions.querySelectorAll('.suggestion-item');
    
    // Remove active class from all items
    items.forEach(item => item.classList.remove('active'));
    
    // Add active class to current item
    if (suggestions._activeIndex >= 0 && suggestions._activeIndex < items.length) {
        items[suggestions._activeIndex].classList.add('active');
        items[suggestions._activeIndex].scrollIntoView({ block: 'nearest' });
    }
}

// Commute Destinations Functionality - Variables declared at top of script

// Initialize commute destinations when maps are ready
function initializeCommuteDestinations() {
    if (window.useGoogleMaps && typeof google !== 'undefined' && google.maps && google.maps.DirectionsService) {
        try {
            directionsServiceCommute = new google.maps.DirectionsService();
            loadCommuteDestinations();
        } catch (error) {
            console.warn('Error initializing DirectionsService for commute destinations:', error);
            directionsServiceCommute = null;
            loadCommuteDestinationsBasic();
        }
    } else {
        // For Leaflet fallback, we'll use estimated times
        directionsServiceCommute = null;
        loadCommuteDestinationsBasic();
    }
}

// Load commute destinations with real-time data
function loadCommuteDestinations() {
    const popularDestinations = document.getElementById('popular-destinations');
    const destinationInfo = document.getElementById('destination-info');
    
    // Show loading state
    destinationInfo.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Loading travel times...';
    
    const userLat = getCurrentUserLatitude();
    const userLng = getCurrentUserLongitude();
    
    if (!userLat || !userLng) {
        // Use default Lagos coordinates if user location not available
        calculateCommuteTimes(6.5244, 3.3792);
    } else {
        calculateCommuteTimes(userLat, userLng);
    }
}

// Calculate travel times to each destination
async function calculateCommuteTimes(originLat, originLng) {
    const destinationList = document.getElementById('destination-list');
    const promises = [];
    
    for (let i = 0; i < commuteDestinations.length; i++) {
        const destination = commuteDestinations[i];
        promises.push(getCommuteTime(originLat, originLng, destination, i));
    }
    
    try {
        const results = await Promise.all(promises);
        displayCommuteDestinations(results.filter(result => result !== null));
    } catch (error) {
        console.error('Error calculating commute times:', error);
        loadCommuteDestinationsBasic();
    }
}

// Get travel time to a specific destination
function getCommuteTime(originLat, originLng, destination, index) {
    return new Promise((resolve) => {
        // Check if Google Maps DirectionsService is available
        if (!directionsServiceCommute || !window.useGoogleMaps || typeof google === 'undefined') {
            // Fallback with estimated time
            const distance = calculateDistance(originLat, originLng, destination.lat, destination.lng);
            const estimatedTime = Math.round(distance * 2.5); // Rough estimate: 2.5 minutes per km
            
            resolve({
                ...destination,
                distance: distance.toFixed(1) + ' km',
                duration: estimatedTime + ' min',
                durationValue: estimatedTime * 60,
                index: index,
                estimated: true
            });
            return;
        }
        
        const request = {
            origin: { lat: originLat, lng: originLng },
            destination: { lat: destination.lat, lng: destination.lng },
            travelMode: google.maps.TravelMode.DRIVING,
            unitSystem: google.maps.UnitSystem.METRIC,
            avoidHighways: false,
            avoidTolls: false,
            region: 'NG'
        };
        
        directionsServiceCommute.route(request, (result, status) => {
            if (status === 'OK') {
                const route = result.routes[0];
                const leg = route.legs[0];
                
                resolve({
                    ...destination,
                    distance: leg.distance.text,
                    duration: leg.duration.text,
                    durationValue: leg.duration.value,
                    index: index
                });
            } else {
                console.warn(`Directions request failed for ${destination.name}:`, status);
                // Fallback with estimated time
                const distance = calculateDistance(originLat, originLng, destination.lat, destination.lng);
                const estimatedTime = Math.round(distance * 2.5); // Rough estimate
                
                resolve({
                    ...destination,
                    distance: distance.toFixed(1) + ' km',
                    duration: estimatedTime + ' min',
                    durationValue: estimatedTime * 60,
                    index: index,
                    estimated: true
                });
            }
        });
    });
}

// Display commute destinations in the dropdown
function displayCommuteDestinations(destinations) {
    const popularDestinations = document.getElementById('popular-destinations');
    const destinationInfo = document.getElementById('destination-info');
    
    // Sort by travel time
    destinations.sort((a, b) => a.durationValue - b.durationValue);
    
    // Clear previous options (except the first placeholder)
    popularDestinations.innerHTML = '<option value="">Select a popular destination...</option>';
    
    destinations.forEach((dest, index) => {
        const estimatedBadge = dest.estimated ? ' (Est.)' : '';
        const option = document.createElement('option');
        option.value = JSON.stringify({
            name: dest.name,
            lat: dest.lat,
            lng: dest.lng,
            duration: dest.duration,
            distance: dest.distance,
            estimated: dest.estimated
        });
        option.textContent = `${dest.name} - ${dest.duration}${estimatedBadge}`;
        popularDestinations.appendChild(option);
    });
    
    // Update info text
    destinationInfo.innerHTML = '<i class="fas fa-check-circle text-success me-1"></i>Travel times updated';
    
    // Clear info after 3 seconds
    setTimeout(() => {
        destinationInfo.innerHTML = '<i class="fas fa-info-circle me-1"></i>Choose destination above';
    }, 3000);
}

// Load basic commute destinations (fallback)
function loadCommuteDestinationsBasic() {
    const popularDestinations = document.getElementById('popular-destinations');
    const destinationInfo = document.getElementById('destination-info');
    const userLat = getCurrentUserLatitude() || 6.5244;
    const userLng = getCurrentUserLongitude() || 3.3792;
    
    // Clear previous options (except the first placeholder)
    popularDestinations.innerHTML = '<option value="">Select a popular destination...</option>';
    
    commuteDestinations.forEach((dest, index) => {
        const distance = calculateDistance(userLat, userLng, dest.lat, dest.lng);
        const estimatedTime = Math.round(distance * 2.5);
        
        const option = document.createElement('option');
        option.value = JSON.stringify({
            name: dest.name,
            lat: dest.lat,
            lng: dest.lng,
            duration: `${estimatedTime} min`,
            distance: `${distance.toFixed(1)} km`,
            estimated: true
        });
        option.textContent = `${dest.name} - ${estimatedTime} min (Est.)`;
        popularDestinations.appendChild(option);
    });
    
    // Update info text
    destinationInfo.innerHTML = '<i class="fas fa-info-circle text-warning me-1"></i>Using estimated times';
}

// Select a popular destination from dropdown
function selectPopularDestination() {
    const popularDestinations = document.getElementById('popular-destinations');
    const destinationInfo = document.getElementById('destination-info');
    const selectedValue = popularDestinations.value;
    
    if (!selectedValue) {
        destinationInfo.innerHTML = '<i class="fas fa-info-circle me-1"></i>Choose destination above';
        return;
    }
    
    try {
        const destination = JSON.parse(selectedValue);
        
        // Set as dropoff location
        document.getElementById('dropoff_location').value = destination.name;
        document.getElementById('dropoff_latitude').value = formatCoordinate(destination.lat);
        document.getElementById('dropoff_longitude').value = formatCoordinate(destination.lng);
        
        // Update info with selected destination details
        const estimatedText = destination.estimated ? ' (Estimated)' : '';
        destinationInfo.innerHTML = `
            <i class="fas fa-map-marker-alt text-success me-1"></i>
            <strong>${destination.name}</strong> - ${destination.duration}, ${destination.distance}${estimatedText}
        `;
        
        // Update estimates and map
        if (typeof updateEstimates === 'function') {
            updateEstimates();
        }
        if (typeof updateMapWithRoute === 'function') {
            updateMapWithRoute();
        }
        
        if (typeof showAlert === 'function') {
            showAlert(`${destination.name} selected as dropoff location`, 'success', 2000);
        }
        
    } catch (error) {
        console.error('Error parsing destination data:', error);
        destinationInfo.innerHTML = '<i class="fas fa-exclamation-triangle text-danger me-1"></i>Error selecting destination';
    }
}

// Select a commute destination as dropoff location (legacy function - kept for compatibility)
function selectCommuteDestination(name, lat, lng) {
    // Set as dropoff location
    document.getElementById('dropoff_location').value = name;
    document.getElementById('dropoff_latitude').value = formatCoordinate(lat);
    document.getElementById('dropoff_longitude').value = formatCoordinate(lng);
    
    // Update estimates and map
    if (typeof updateEstimates === 'function') {
        updateEstimates();
    }
    if (typeof updateMapWithRoute === 'function') {
        updateMapWithRoute();
    }
    
    if (typeof showAlert === 'function') {
        showAlert(`${name} selected as dropoff location`, 'success', 2000);
    }
}

// Refresh commute times
function refreshCommuteTimes() {
    if (window.useGoogleMaps && typeof google !== 'undefined') {
        loadCommuteDestinations();
    } else {
        loadCommuteDestinationsBasic();
    }
    // showAlert('Refreshing travel times...', 'info', 2000);
}

// Get current user coordinates
function getCurrentUserLatitude() {
    return document.getElementById('pickup_latitude').value || null;
}

function getCurrentUserLongitude() {
    return document.getElementById('pickup_longitude').value || null;
}

// Show add destination modal (placeholder for future enhancement)
function showAddDestinationModal() {
    showAlert('Custom destinations coming soon!', 'info', 3000);
}

// Initialize commute destinations when the page loads
document.addEventListener('DOMContentLoaded', function() {
    // Wait a bit for map initialization
    setTimeout(() => {
        initializeCommuteDestinations();
    }, 2000);
});
</script>
{% endblock %}
